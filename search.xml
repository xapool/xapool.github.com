<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Wine：因找不到 tlb 文件所导致的栈溢出</title>
      <link href="2022/05/22/wine-wpf-tlb-debug/"/>
      <url>2022/05/22/wine-wpf-tlb-debug/</url>
      
        <content type="html"><![CDATA[<p>有一款 WPF 应用在 Wine 下启动时，会重复不断地打印很多如下的 log，最后因 StackOverflowException 而崩溃：</p><blockquote><p>err:ole:TLB_ReadTypeLib Loading of typelib L&quot;C:\Program Files\xxxxx\xxxxxxx.tlb&quot; failed with error 2</p></blockquote><a id="more"></a><h2 id="问题程序集"><a class="header-anchor" href="#问题程序集">¶ </a>问题程序集</h2><p>tlb 是类型库文件，<code>error 2</code> 是找不到此文件。既然如此，把此程序集的 tlb 文件放到指定路径是否可行呢？<br>要验证一下，就得有此程序集的 tlb 文件。好在，经过检索，可使用 dotnet 的 RegAsm 来生成。</p><p>在 Windows 下执行以下命令：</p><blockquote><p>C:\Program Files\xxxxx&gt;C:\windows\<a href="http://microsoft.net" target="_blank" rel="noopener">microsoft.net</a>\framework\v4.0.30319\RegAsm.exe /codebase xxxxxxx.dll /tlb xxxxxxx.tlb</p></blockquote><p>但出错了：</p><blockquote><p>RegAsm : error RA0000 : 类型库导出程序在处理“xxxxxxx.xxxxxxxxxx, xxxxxxx”时遇到了错误。错误: 找不到元素。</p></blockquote><p>使用 tlbexp 工具来导出，也是同样的错误。而其他的程序集在导出 tlb 时并没有遇到过此问题。<br>使用 ILSpy 打开此 dll，找到出问题的类时，发现此 dll 中所有的类要导出 COM 时，使用的是同一个 GUID。而在 Windows 使用 x64dbg 调试此程序时，也发现了在调用 <code>CreateTypeLib2</code> 后，出现了同样找不到元素的错误日志。</p><p>那么，结论就是此程序集本身存在问题，但 Wine 无法兼容这种有问题的程序集，导致栈溢出。</p><h2 id="dirty-workaround"><a class="header-anchor" href="#dirty-workaround">¶ </a>Dirty Workaround</h2><p>延续上面的思路，使用 ildasm/ilasm 将重复的 GUID 修改掉后，最后在 Windows 下可成功导出 tlb 文件。将此 tlb 文件放到指定路径后，可修复栈溢出的问题。</p><p>此 dirty workaround 显然不太好，因为 Windows 下并不需要此 tlb 文件，还是要尝试找到出问题的代码。栈溢出通常是没有满足递归的出口造成的，所以需要对比下在 Windows 下程序正常执行时的逻辑。<br>打开 <code>+ole,+typelib,+seh</code> 调试频道，重点关注在调用 <code>CreateTypeLib2</code> 后，对返回的 COM 组件虚表中函数的调用逻辑，对比在 Windows 下使用 x64dbg 进行单步调试时分析出的逻辑，发现 Windows 很早就对有问题的类进行了返回，而 Wine 并不是。<br>Wine 直到 <code>ITypeInfo_fnGetRefTypeOfImplType FAILURE -- hresult 0x8002802b.</code> 才返回 0x8002802b，而后就是进入到另一个递归循环。</p><p>修改 Wine 的代码 <code>dlls/oleaut32/typelib.c</code>，尝试在 <code>ICreateTypeLib2_fnCreateTypeInfo</code> 时判断下若是有此问题的类，则直接返回 <code>TYPE_E_ELEMENTNOTFOUND</code>，这样同 Windows 下的逻辑就一致了。这又是一个 dirty workaround，既然是 dirty workaround，那就不止这几种，尝试其它了几种都是可行的。</p><p>但是要写出一个能被 Wine 接受的 patch，还需要对 Wine 的 <code>dlls/oleaut32/typelib.c</code> 进一步分析与理解，还需努力。</p>]]></content>
      
      
      <categories>
          
          <category> Wine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wine：InDesignCS6 导出 PDF 时的崩溃问题</title>
      <link href="2022/05/21/wine-indesign-export-crash-debug/"/>
      <url>2022/05/21/wine-indesign-export-crash-debug/</url>
      
        <content type="html"><![CDATA[<p>Wine AppDB 上记录的对 <a href="https://appdb.winehq.org/objectManager.php?sClass=version&amp;iId=26506" target="_blank" rel="noopener">Adobe InDesign CS6</a> 支持不错，但在使用的过程中，有一个严重的 bug。若是选择 “Adobe 打印” 的方式导出 pdf，会造成程序的崩溃。</p><a id="more"></a><h2 id="崩溃日志"><a class="header-anchor" href="#崩溃日志">¶ </a>崩溃日志</h2><p>崩溃信息如下(截取部分)：</p><blockquote><p>Unhandled exception: page fault on read access to 0x00000000 in 32-bit code (0x00981d1d).<br>Register dump:<br>CS:0023 SS:002b DS:002b ES:002b FS:0063 GS:006b<br>EIP:00981d1d ESP:3241f740 EBP:3241f754 EFLAGS:00010287(  R- –  I S - -P-C)<br>EAX:00000000 EBX:00000000 ECX:3241f748 EDX:292676e8<br>ESI:291b5788 EDI:00003ee1<br>Stack dump:<br>0x3241f740:  0defc619 0defcaa0 3241f81c 0df191db<br>0x3241f750:  ffffffff 3241f760 0defcab3 292d33f8<br>0x3241f760:  3241f77c 100135dc 291b5788 27ef6ec8<br>0x3241f770:  08027fe0 00000010 00003e01 3241f7a8<br>0x3241f780:  1000e581 00000000 00003ee1 27ef6ec8<br>0x3241f790:  00003e13 00000101 00000000 27ef6ec8<br>Backtrace:<br>=&gt;0 0x00981d1d in pmruntime (+0x1d1d) (0x3241f754)<br>1 0x0defcab3 in font manager.rpln (+0x4cab3) (0x3241f760)<br>2 0x100135dc in objectmodel (+0x135dc) (0x3241f77c)<br>3 0x1000e581 in objectmodel (+0xe581) (0x3241f7a8)<br>4 0x1001b802 in objectmodel (+0x1b802) (0x3241f7d0)<br>5 0x1001a8cb in objectmodel (+0x1a8cb) (0x3241f7e0)<br>6 0x0def3024 in font manager.rpln (+0x43024) (0x3241f828)<br>7 0x0def32e3 in font manager.rpln (+0x432e3) (0x3241f834)<br>…<br>…<br>0x00981d1d pmruntime+0x1d1d: cmpl$0,0x0(%eax)</p></blockquote><h2 id="问题分析"><a class="header-anchor" href="#问题分析">¶ </a>问题分析</h2><p>崩溃的原因是 page fault，地址是 <code>0x00981d1d in pmruntime (+0x1d1d)</code>，汇编代码 <code>cmpl$0,0x0(%eax)</code>，取 eax 的值与零进行比较，但通过上面的 Register dump，eax 的内容是零，对零解引用，就造成了 page fault。<br>eax 通常用做存储函数的返回值。所以这种问题，如果程序没有加壳的话，可以直接使用 IDA F5 键看下崩溃处的代码，看下在出问题的指令前调用了什么函数。</p><p>F5 键结果:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL __cdecl K2Memory::IsUIThread()</span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *v0; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  v0 = NtCurrentTeb()-&gt;NtTib.FiberData;</span><br><span class="line">  <span class="keyword">return</span> v0 != (_DWORD *)<span class="number">7680</span> &amp;&amp; !*v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题出在 <code>*v0</code>, <code>NtCurrentTeb()-&gt;NtTib.FiberData</code> 的返回值是零。这里有 <a href="https://bbs.pediy.com/thread-223816.htm#msg_header_h2_7" target="_blank" rel="noopener">TEB NtTib 结构体的介绍</a>，FiberData 经过查询资料得知是关于协程的一个东西，跟了以下 Wine 的代码，也没搞明白该如何修复。使用 x64dbg 单步调试了下在此处的逻辑后，发现直接 nop 出问题的指令，好像并无影响。</p><p>原汇编代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">10001</span>D10 ; <span class="keyword">bool</span> __cdecl K2Memory::IsUIThread(K2Memory *__hidden <span class="keyword">this</span>)</span><br><span class="line">.text:<span class="number">10001</span>D10                 <span class="keyword">public</span> ?IsUIThread@K2Memory@@YA_NXZ</span><br><span class="line">.text:<span class="number">10001</span>D10 ?IsUIThread@K2Memory@@YA_NXZ proc near  ; DATA XREF: .rdata:off_1000A588↓o</span><br><span class="line">.text:<span class="number">10001</span>D10</span><br><span class="line">.text:<span class="number">10001</span>D10 <span class="keyword">this</span>            = dword ptr  <span class="number">4</span></span><br><span class="line">.text:<span class="number">10001</span>D10</span><br><span class="line">.text:<span class="number">10001</span>D10                 mov     eax, large fs:<span class="number">10</span>h</span><br><span class="line">.text:<span class="number">10001</span>D16                 cmp     eax, <span class="number">1E00</span>h</span><br><span class="line">.text:<span class="number">10001</span>D1B                 jz      <span class="keyword">short</span> loc_10001D28</span><br><span class="line">.text:<span class="number">10001</span>D1D                 cmp     dword ptr [eax], <span class="number">0</span></span><br><span class="line">.text:<span class="number">10001</span>D20                 jnz     <span class="keyword">short</span> loc_10001D28</span><br><span class="line">.text:<span class="number">10001</span>D22                 mov     eax, <span class="number">1</span></span><br><span class="line">.text:<span class="number">10001</span>D27                 retn</span><br><span class="line">.text:<span class="number">10001</span>D28 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">10001</span>D28</span><br><span class="line">.text:<span class="number">10001</span>D28 loc_10001D28:                           ; CODE XREF: K2Memory::IsUIThread(<span class="keyword">void</span>)+B↑j</span><br><span class="line">.text:<span class="number">10001</span>D28                                         ; K2Memory::IsUIThread(<span class="keyword">void</span>)+<span class="number">10</span>↑j</span><br><span class="line">.text:<span class="number">10001</span>D28                 xor     eax, eax</span><br><span class="line">.text:<span class="number">10001</span>D2A                 retn</span><br><span class="line">.text:<span class="number">10001</span>D2A ?IsUIThread@K2Memory@@YA_NXZ endp</span><br></pre></td></tr></table></figure><p>修改后的汇编：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">10001</span>D10 ; <span class="keyword">bool</span> __cdecl K2Memory::IsUIThread(K2Memory *__hidden <span class="keyword">this</span>)</span><br><span class="line">.text:<span class="number">10001</span>D10                 <span class="keyword">public</span> ?IsUIThread@K2Memory@@YA_NXZ</span><br><span class="line">.text:<span class="number">10001</span>D10 ?IsUIThread@K2Memory@@YA_NXZ proc near  ; DATA XREF: .rdata:off_1000A588↓o</span><br><span class="line">.text:<span class="number">10001</span>D10</span><br><span class="line">.text:<span class="number">10001</span>D10 <span class="keyword">this</span>            = dword ptr  <span class="number">4</span></span><br><span class="line">.text:<span class="number">10001</span>D10</span><br><span class="line">.text:<span class="number">10001</span>D10                 mov     eax, large fs:<span class="number">10</span>h</span><br><span class="line">.text:<span class="number">10001</span>D16                 cmp     eax, <span class="number">1E00</span>h</span><br><span class="line">.text:<span class="number">10001</span>D1B                 jz      <span class="keyword">short</span> loc_10001D28</span><br><span class="line">.text:<span class="number">10001</span>D1D                 nop</span><br><span class="line">.text:<span class="number">10001</span>D1E                 nop</span><br><span class="line">.text:<span class="number">10001</span>D1F                 nop</span><br><span class="line">.text:<span class="number">10001</span>D20                 nop</span><br><span class="line">.text:<span class="number">10001</span>D21                 nop</span><br><span class="line">.text:<span class="number">10001</span>D22                 mov     eax, <span class="number">1</span></span><br><span class="line">.text:<span class="number">10001</span>D27                 retn</span><br><span class="line">.text:<span class="number">10001</span>D28 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">10001</span>D28</span><br><span class="line">.text:<span class="number">10001</span>D28 loc_10001D28:                           ; CODE XREF: K2Memory::IsUIThread(<span class="keyword">void</span>)+B↑j</span><br><span class="line">.text:<span class="number">10001</span>D28                 xor     eax, eax</span><br><span class="line">.text:<span class="number">10001</span>D2A                 retn</span><br><span class="line">.text:<span class="number">10001</span>D2A ?IsUIThread@K2Memory@@YA_NXZ endp</span><br></pre></td></tr></table></figure><p>还有一种修改 Wine 代码的 dirty workaround，修改 ntdll 的 <code>dispatch_exception</code> 函数，对此 page fault 异常进行处理，让 <code>Eip + 5</code> 后，跳过出问题的指令，让程序继续运行。</p>]]></content>
      
      
      <categories>
          
          <category> Wine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wine 与国产化操作系统</title>
      <link href="2022/05/20/wine-and-made-in-china/"/>
      <url>2022/05/20/wine-and-made-in-china/</url>
      
        <content type="html"><![CDATA[<p>Wine 是一个免费和开源的兼容层，目的是为了在类 Unix 操作系统上运行 Windows 应用。Wine 的特殊之处是它并不是像模拟器一样模拟出一个完整的 Windows 环境。而是將 Windows API 调用转换为 POSIX API 调用，重新创建 Windows 的目录结构，并提供 Windows 系统库、系统服务和其它各种组件的替代实现。以让 Windows 原生应用二进制，无需经过修改，或重新编译，就可运行在 Linux/MacOS/Android 系统上。</p><a id="more"></a><p>Wine 主要通过黑盒测试与逆向工程来研发，相对于正向研发，既耗时又困难。主要是因为 Windows API 的文档不完整且不完全准确。尽管 MSDN 详细介绍了大多数的 Win32 功能，但某些领域，如文件格式和协议，微软并没有提供公开的规范，而且 Windows 还存在一些文档并未提到的低级函数、行为和未知错误，Wine 必须精确复制这些错误才能让某些应用程序正常运行。因此，Wine 团队在 thunking 等领域对许多函数调用和文件格式进行了逆向工程。</p><p>Wine 项目最初采用了 MIT 许可证，但由于担心 Wine 的专有版本不会将其更改回馈给核心项目，所以后来使用 LGPL 作为其许可证。Wine 开发版本大约每两周发布一次，稳定版一年发布一次。</p><p>Wine 的主要企业赞助商是 CodeWeavers，它雇佣了 Julliard 和许多其他 Wine 开发人员来开发 Wine 和 CrossOver。CrossOver 是 CodeWeavers 公司所支持的商业 Wine 版本。CrossOver 包括一些不适合上游版本的特定于应用程序的调整，以及一些额外的专有组件。CrossOver 遵循 LGPL 协议，同样也是开源的，其大部分代码都会贡献给 Wine。</p><h2 id="国产化"><a class="header-anchor" href="#国产化">¶ </a>国产化</h2><p>自从贸易战后，国内对国产化的补贴投入力度加大，在计算机软硬件领域同样如此，要实现对计算机软硬件的自主、可控，行业迎来了新的东风。CEC/CETC/中科院/工信部等高校、国企，纷纷争抢此块蛋糕，旗下公司进行整合、合并，软硬件商联手，有统信的建立、天津中标与麒麟的合并、曙光入股方德等等，以增强自身的优势与竞争力。</p><p>而其中的国产操作系统商，除了 deepin 有些个人用户在使用，其它的厂商完全依赖于政府的补贴与采购。其生态环境，最初也仅仅是为了满足于政府部门的办公需求。但随着 Wine 开源项目的愈加成熟，各国产操作系统商纷纷做起了 Wine 的适配，以做大自己的生态。有的是和 CrossOver 达成商业合作，有的完全基于 Wine 进行二次开发与适配，目前所知，统信、麒麟、方德都在做这块的业务。但得益于圈内的某些“优良”传统，几乎没有遵守协议，进行开源的。</p><p>这就是所谓的国产化。</p><h2 id="参考"><a class="header-anchor" href="#参考">¶ </a>参考</h2><ul><li><a href="https://en.wikipedia.org/wiki/Wine_(software)" target="_blank" rel="noopener">Wine</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Wine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Treble 架构下的 HAL</title>
      <link href="2018/11/09/android-treble-hidl/"/>
      <url>2018/11/09/android-treble-hidl/</url>
      
        <content type="html"><![CDATA[<p>在 Android 8.0 时，Treble Project 重新设计了 Android 操作系统框架，以便让制造商能够以更低的成本，更轻松、更快速地将设备更新到新版 Android。在这种新架构中，采用 HIDL（HAL 接口定义语言，发音为 “hide-l”）来指定 framework 和 HAL 层之间的接口，从而可以实现无需重新编译 HAL，只烧写 <a href="https://source.android.com/setup/build/gsi" target="_blank" rel="noopener">GSI</a> 便能升级系统。</p><a id="more"></a><h2 id="hal-类型和概念"><a class="header-anchor" href="#hal-类型和概念">¶ </a>HAL 类型和概念</h2><p>这一块感觉官方文档的描述不够清楚，稀里糊涂的，单读文档概念都不明白。尝试先搞清楚 Treble 中绑定式和直通式 HAL 的概念。官方的中文翻译是：</p><ul><li>绑定式 HAL。 以 HAL 接口定义语言 (HIDL) 表示的 HAL。这些 HAL 取代了早期 Android 版本中使用的传统 HAL 和旧版 HAL。在绑定式 HAL 中，Android 框架和 HAL 之间通过 Binder 进程间通信 (IPC) 调用进行通信。所有在推出时即搭载了 Android 8.0 或更高版本的设备都必须只支持绑定式 HAL</li><li>直通式 HAL。 以 HIDL 封装的传统 HAL 或旧版 HAL。这些 HAL 封装了现有的 HAL，可在绑定模式和 Same-Process（直通）模式下使用。升级到 Android 8.0 的设备可以使用直通式 HAL</li></ul><p>这里的绑定式 HAL(Binderized HALs)、直通式 HAL (Passthrough HALs)，应该指的是 HAL 层的共享库 .so 文件。其中直通式 HAL，是把 Treble Project 之前的传统 HAL 或旧版 HAL 库文件使用 HIDL 进行了封装，而封装后的库文件可用于 Treble Project 中的绑定模式和 Same-Process（直通）模式。</p><p>在看一下官方的 roadmap:</p><p><img src="/media/treble_cpp_legacy_hal_progression.png" alt="HAL Roadmap" title="HAL Roadmap"></p><p>这 ①②③④ 四种模式，是到目前为止四种实现架构。</p><ol><li>① 是 Treble Project 之前使用的实现架构，使用的是传统 HAL 和旧版 HAL</li><li>② 直通模式，passthrough mode。如图所示，Framework 和 HAL 层工作在同一个进程当中，下面的 HAL 是使用 HIDL 封装后的库，是直通式 HAL。这些库文件也可用于 ③ 绑定模式</li><li>③ 绑定模式，binderized mode。是直通式 HAL binder 化，变为绑定式 HAL。Framework 和  HAL 层工作在不同的进程，之间通过 Binder 进行 IPC</li><li>④ 纯绑定式。相对于 ③ 来说，绑定式 HAL 中并不包含直通式 HAL，因此称为纯绑定式</li></ol><p>因此根据谷歌要求，出厂时就搭载 8.0 的设备，除了谷歌规定的 android.hardware.graphics.mapper@1.0 和 android.hardware.renderscript@1.0 需使用 ②直通模式，其它 HAL 只能采用 ③ 和 ④ 模式的实现架构。</p><p>而升级到 8.0 的设备，除谷歌规定外，其它 HAL 则可使用 ②③④ 三种实现架构。既是供应商映像提供的所有其他 HAL 既可以在直通模式下使用，也可以在绑定模式下使用，也可完全使用纯绑定式。</p><p>补充：<br>旧版 HAL 是直接被编译进系统，如 WLAN 就在<a href="https://android.googlesource.com/platform/hardware/libhardware_legacy/+/refs/tags/android-7.1.2_r36" target="_blank" rel="noopener">libhardware_legacy</a> 中；传统 HAL 是通过 libhardware 库中 <a href="https://android.googlesource.com/platform/hardware/libhardware/+/refs/tags/android-8.1.0_r65/hardware.c#216" target="_blank" rel="noopener">get_hw_module()</a> 的方式来获取。未使用 HIDL 表示的 HAL 有 openGL 和 Vulkan。</p><h2 id="实现模式的架构差异"><a class="header-anchor" href="#实现模式的架构差异">¶ </a>实现模式的架构差异</h2><p>②③④ 三种实现架构从实现上来看，当然也是不同的</p><h3 id="直通模式"><a class="header-anchor" href="#直通模式">¶ </a>直通模式</h3><p>和 Framework 工作在同一个进程当中，因没有 service 进程，服务也没有被事先注册到 hwservicemanager，Framework 通过 Binder 得到的是同一个进程中的实例。在 manifest.xml 中 transport 类型为 passthrough。以 android.hardware.graphics.composer@2.1 为例，在 <a href="https://android.googlesource.com/platform/hardware/interfaces/+/refs/tags/android-8.1.0_r65/graphics/composer/2.1/default/Android.bp#22" target="_blank" rel="noopener">Android.bp</a> 中，Hwc.cpp 被编译为 <code>android.hardware.graphics.composer@2.1-impl.so</code>，其 <a href="https://android.googlesource.com/platform/hardware/interfaces/+/refs/tags/android-8.1.0_r65/graphics/composer/2.1/default/Hwc.cpp#747" target="_blank" rel="noopener">HIDL_FETCH_IComposer</a> 方法中会使用 hw_get_module() 方法去加载传统 HAL。</p><h3 id="绑定模式"><a class="header-anchor" href="#绑定模式">¶ </a>绑定模式</h3><p>而将直通模式中的直通式 HAL，添加上 service 进程，修改 transport 类型为 hwbinder，就成为了绑定模式。service 的注册使用的是 <a href="https://android.googlesource.com/platform/hardware/interfaces/+/refs/tags/android-8.1.0_r65/graphics/composer/2.1/default/service.cpp#43" target="_blank" rel="noopener">defaultPassthroughServiceImplementation()</a> 方法。</p><h3 id="纯绑定式"><a class="header-anchor" href="#纯绑定式">¶ </a>纯绑定式</h3><p>service 的注册方法都是 <code>registerAsService()</code>，在 manifest.xml 中的 transport 类型为 hwbinder，不再单独编译 <code>*-impl.so</code>，而是全编译进 service 中。以 android.hardware.power@1.1 默认实现为例。android.hardware.power@1.1-service 服务启动时，服务的注册方法是 <a href="https://android.googlesource.com/platform/hardware/interfaces/+/62cc79bdf0c52c773602d9e93bbf732b1c54b934/power/1.1/default/service.cpp#74" target="_blank" rel="noopener">registerAsService()</a>。在 <a href="https://android.googlesource.com/platform/hardware/interfaces/+/62cc79bdf0c52c773602d9e93bbf732b1c54b934/power/1.1/default/Android.bp#21" target="_blank" rel="noopener">Android.bp</a> 中将两个源文件编译为 android.hardware.power@1.1-service。有意思的是在 service 的 main 方法中居然会去 <a href="https://android.googlesource.com/platform/hardware/interfaces/+/62cc79bdf0c52c773602d9e93bbf732b1c54b934/power/1.1/default/service.cpp#47" target="_blank" rel="noopener">hw_get_module(POWER_HARDWARE_MODULE_ID, &amp;hw_module)</a> 加载传统 HAL，那这个默认实现 1.1 版相对于 1.0 版就没有意义了。也因并没有厂商使用这个默认版，<a href="https://android.googlesource.com/platform/hardware/interfaces/+/4497a5fe338c4a19dc31312641b2caa8454eb24e" target="_blank" rel="noopener">谷歌干脆移除了</a>。</p><h3 id="小结"><a class="header-anchor" href="#小结">¶ </a>小结</h3><p>在直通模式和绑定模式中，<code>*-impl.so</code> 库文件通过 <code>HIDL_FETCH_I***</code> 方法来加载传统 HAL，因此厂商也可把所有的实现放入 impl 中，如 health 和 bluetooth 的默认实现，在 HIDL_FETCH_IHealth 返回的是自己的实例。纯绑定式中，厂商的实现就都在 service 当中了。</p><h2 id="服务的注册和获取"><a class="header-anchor" href="#服务的注册和获取">¶ </a>服务的注册和获取</h2><p>服务注册或获取服务端实例过程中，都会传递一个布尔值 getStub：</p><ol><li>getStub 为 true 时，不会去读 manifest.xml 中指定 transport 类型</li><li>getStub 为 false 时，则会读取 manifest.xml 中 transport 类型</li></ol><h3 id="服务的注册"><a class="header-anchor" href="#服务的注册">¶ </a>服务的注册</h3><p>上面也提到了，服务的注册方法有两个，<code>defaultPassthroughServiceImplementation()</code> 由绑定模式使用；<code>registerAsService()</code> 由纯绑定模式使用。因直通模式并没有 service deamon，因此系统启动时，并不会进行注册。</p><h4 id="绑定模式-v2"><a class="header-anchor" href="#绑定模式-v2">¶ </a>绑定模式</h4><p>绑定模式调用 <code>defaultPassthroughServiceImplementation()</code> 方法，在其调用链中会调用 <code>getService()</code> 方法，并传递 getStub 为 true。getService 会首先获取 hwservicemanager 代理对象，请求 hwservicemanager 进程查询所要注册的 HIDL 服务的 transport 类型(通过读取 /vendor/manifest.xml 文件)。因为传递的 getStub 为 ture，所以这里获取到的 transport 类型在注册时并不起什么作用，将始终通过 <code>getPassthroughServiceManager()</code> 方法获取一个 PassthroughServiceManager 对象，调用其 <code>get(const hidl_string&amp; fqName, const hidl_string&amp; name)</code> 方法来获取所要注册的 HIDL 服务对象(如图所示)，最后调用 registerReference 和 registerAsService 完成服务的注册。</p><p><img src="/media/get_hidl_service.png" alt="Get HIDL Service" title="get hidlservice"></p><h4 id="纯绑定模式"><a class="header-anchor" href="#纯绑定模式">¶ </a>纯绑定模式</h4><p>纯绑定式，使用不到绑定模式前面的那些，直接 registerAsService，注册到 hwservicemanager。</p><h4 id="参考"><a class="header-anchor" href="#参考">¶ </a>参考</h4><p>详见：<a href="https://blog.csdn.net/yangwen123/article/details/79854267" target="_blank" rel="noopener">AndroidO Treble架构下Hal进程启动及HIDL服务注册过程</a>，就不贴代码了。</p><h3 id="服务的查询获取"><a class="header-anchor" href="#服务的查询获取">¶ </a>服务的查询获取</h3><p>获取服务时的 getService 方法过程中，传递的 getStub 为 false，因此根据指定的 transport 类型来选择接口对象获取方式：</p><ul><li>为 passthrough 时，使用 <code>getPassthroughServiceManager()</code> 方法从本进程地址空间中获取</li><li>为 hwbinder 时，先使用 <code>defaultServiceManager()</code> 方法获取 hwservicemanager 的代理对象，然后从 hwservicemanager 中查询获取</li></ul><h4 id="passthrough"><a class="header-anchor" href="#passthrough">¶ </a>passthrough</h4><p>直通模式下客户端去获取服务，和绑定模式注册时服务时对 HIDL 服务的获取过程是一致的。</p><p><code>getPassthroughServiceManager()</code>，返回一个 PassthroughServiceManager 对象，这个 PassthroughServiceManager 类是 <code>system/libhidl/transport/ServiceManagement.cpp</code> 的一个内部类。</p><p><s>直通模式因事先没有被注册到 hwservicemanager 中去，在客户端申请服务时，才会一并注册到 hwservicemanager，若并没有客户端申请该服务，那么 hwservicemanager 中就不会存在该服务，直通模式最后获取到的是同一进程中的实例，不是一个代理对象。</s></p><h4 id="hwbinder"><a class="header-anchor" href="#hwbinder">¶ </a>hwbinder</h4><p>在绑定模式和纯绑定模式下，<code>getService()</code> 时，调用的是 libhidl 库中的 <code>defaultServiceManager()</code>，通过 binder 返回的是 HwServiceManager 实例，最终远程调用 hwservicemanager daemon 中的方法，获取到代理对象</p><h4 id="参考-v2"><a class="header-anchor" href="#参考-v2">¶ </a>参考</h4><p>详见：<a href="https://blog.csdn.net/yangwen123/article/details/79868548" target="_blank" rel="noopener">AndroidO Treble 架构下 HIDL 服务查询过程</a></p><h2 id="参考-v3"><a class="header-anchor" href="#参考-v3">¶ </a>参考</h2><ul><li><a href="https://blog.csdn.net/xiaosayidao/article/details/75577940" target="_blank" rel="noopener">Android Treble架构解析</a></li><li><a href="http://qinyuyin.gitlab.io/2018-07-04/" target="_blank" rel="noopener">HwServiceManager 学习</a></li><li><a href="http://zhoujinjian.cc/2018/09/28/Android%20O%20Treble%20%E6%9E%B6%E6%9E%84%20-%20HIDL%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/index.html#%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%81Android-O-Treble-%E4%B9%8B-hwservicemanager-%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1%EF%BC%88add%EF%BC%89%E8%BF%87%E7%A8%8B" target="_blank" rel="noopener">Android O Treble 架构 - HIDL源代码分析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HAL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tmux 简明指南</title>
      <link href="2017/11/03/Tmux-Guide/"/>
      <url>2017/11/03/Tmux-Guide/</url>
      
        <content type="html"><![CDATA[<p>Tmux 做为一利器，很早就知道了，但是一直没有搞明白其使用场景，甚至一直在以错误的方式使用。现今花点时间搞明白它。</p><p>首先就是使用场景的问题，至于具体的命令以后在慢慢记忆。</p><a id="more"></a><h2 id="update"><a class="header-anchor" href="#update">¶ </a>Update</h2><ol><li>在 iTerm2 中 re-attach 一个会话后，中文输入有问题，参考这个 <a href="https://gitlab.com/gnachman/iterm2/issues/5551" target="_blank" rel="noopener">issue</a>，是 tmux 的 bug，升级到 2.3 及以上版本即可解决，Ubuntu 16.04 源中的版本比较低，需要重新编译安装</li><li>因为 mosh 并不支持使用 <code>tmux -CC</code> 参数，因此使用 <a href="https://github.com/MisterTea/EternalTerminal" target="_blank" rel="noopener">et</a> 替代</li><li>当服务端重启后，每次都得重新新建会话，打开一堆窗口，因此使用 tmux 插件 <a href="https://github.com/tmux-plugins/tmux-resurrect" target="_blank" rel="noopener">tmux-resurrect</a> 来<a href="https://blog.csdn.net/xy707707/article/details/80834428" target="_blank" rel="noopener">保存会话和恢复会话</a>，使用<a href="https://github.com/tmux-plugins/tmux-continuum" target="_blank" rel="noopener">tmux-continuum</a>插件来自动保存会话，默认每十五分钟保存一次。</li></ol><p><em>注意</em>：但因为在和 iTerm2 集成的情况下，并不能使用 Ctrl + b，因此需要手动保存执行命令来保存会话状态 <a href="https://github.com/tmux-plugins/tmux-resurrect/issues/179#issuecomment-304748076" target="_blank" rel="noopener">issue</a>。在使用 resurrect 插件后，还会导致一个问题 <a href="https://github.com/tmux-plugins/tmux-sensible/issues/24#issuecomment-251045335" target="_blank" rel="noopener">issue</a>，这些 issue 中都有解决办法。还有一个需要注意的是，在新建一个会话后，先 detach, 然后执行脚本进行恢复，再 re-attach，直接在会话中进行 re-attach 时有问题。</p><h2 id="使用场景"><a class="header-anchor" href="#使用场景">¶ </a>使用场景</h2><ol><li>在远程机器上安装和使用 tmux。一般使用 SSH 登陆到远程机器上后，若 SSH 断开后，在重新登陆，但是原先的窗口中的输出啊什么的就看不到了。若 SSH 登陆后，使用 tmux 命令开启一个会话，就算 SSH 断开了，你在重新登陆后，直接 attach 到原先的会话，就回到了原先的工作现场。而且在会话的窗口中可以使用 tmux 的快捷键开启多个面板，不需要在来一个 SSH 连接过去了。在 SSH 登陆的时候，使用 <code>ssh user@host &quot;command&quot;</code> 或 <code>ssh user@host -- command</code>，直接在远程机器上执行命令，如 tmux。</li><li>在本地机器上安装使用 tmux。在本地使用的话，可以方便的分屏，在会话和终端中切换，减少窗口数量等。这些iTerm2 就可以啦，一般还是在远程机器上使用。不过 detach 后，倒是可以变相的隐藏窗口…</li></ol><h2 id="tmux-的使用"><a class="header-anchor" href="#tmux-的使用">¶ </a>Tmux 的使用</h2><p>Ctrl + b，然后 d，就会从当前会话中分离，回到原先终端。在原先终端中 <code>tmux attach</code>，就可以来到原先的会话。</p><p>在 tmux 的会话中，按下 Ctrl + b 后是激活控制台，输入 ? 可以显示控制台命令帮助。</p><p>如果有多个会话，可以使用 <code>tmux ls</code> 查看，然后 <code>tmux attach -t sessionname</code> 进入到这个会话。</p><p>命令可以查看这个 <a href="https://gist.github.com/MohamedAlaa/2961058" target="_blank" rel="noopener">CheatSheet</a></p><h2 id="mac-上和-iterm2-的集成"><a class="header-anchor" href="#mac-上和-iterm2-的集成">¶ </a>Mac 上和 iTerm2 的集成</h2><p>如果本地机器使用的是 iTerm2，在 SSH 远程连接中使用 <code>tmux -CC</code> 命令，一个新的 tmux 会话就会被创建，并会开启一个新的窗口，而且 iTerm2 会接管 tmux 的功能，如分屏，就无需使用 tmux 的命令来进行了，可直接在这个新的窗口中使用 iTerm2 的快捷键，还有如历史查找等快捷键，也没必要对远程机器进行单独配置这些了。关闭某个面板时，选择 Hide，就可以使用 <code>tmux -CC attach</code> 命令来 attach 了。这个依然是使用场景1。</p><p>在 iTerm2 的 <code>Preferences &gt; general</code> 中有一项 <code>tmux Integration</code>，可以对集成的 tmux 进行一些设置，如打开新窗口做为本地 tab，执行 <code>tmux -CC attach</code> 后，隐藏本窗口等。</p><p>使用 mosh 替代 ssh，mosh 会自动断开重连，需要在两端都安装。不过若使用 mosh 的连接，并不能使用 <code>-CC</code> 参数，参见该 <a href="https://github.com/mobile-shell/mosh/issues/640" target="_blank" rel="noopener">issue</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tmux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 之多态的实现</title>
      <link href="2017/10/15/JVM-Polymorphism/"/>
      <url>2017/10/15/JVM-Polymorphism/</url>
      
        <content type="html"><![CDATA[<p>这部分的笔记在国庆假期前就整理好了，然后说再加工一下，放到 blog 上，毕竟笔记只是适合自己看，没有很强的逻辑性。但每个假期回来后，都会患上一定的假期综合征，总需要几天收收心。就一直拖到现在，简直无可救药。</p><p>OOP 的三大特征：封装、继承、多态。以前记忆的时候都是不分先后，随便记忆的，加深理解后才知道这三个特性是一个递进的过程。最后的多态是在继承的基础之上的。</p><p>这里先从 JVM 方法调用说起，最后在得出多态的概念。</p><a id="more"></a><h2 id="方法调用指令"><a class="header-anchor" href="#方法调用指令">¶ </a>方法调用指令</h2><p>在 JVM 中有四个主要的方法调用指令：</p><ul><li>invokestatic</li><li>invokespecial</li><li>invokevirtual</li><li>invokeinterface</li></ul><p>在 Class 文件中，这些方法调用指令后面跟着的是要调用方法的符号引用。这些符号引用最终都要在类加载阶段或运行期转化为直接引用。</p><p>其中 invokestatic 和 invokespecial 这两个指令调用的方法称为解析调用，是一个静态过程， 在编译期间就完全确定。要调用方法的符号引用在运行时常量池中已经在类加载的解析阶段被解析为了方法的直接引用，就不需要在运行期去方法表中查找了。这些方法有静态方法、私有方法、实例构造器，称为<strong>非虚方法</strong>。</p><p>其中 invokestatic 用于调用静态方法，invokespecial 用于调用私用方法和实例构造器。此外虽然被 final 修饰的方法是使用 invokesvirtual 来调用的，但由于 final 方法无法被子类覆写，只存在唯一版本，所以也是一种非虚方法。这也是这些方法无法被继承或覆写在 JVM 的体现。</p><p>而 invokesvirtual 和 invokeinterface 这两个指令调用的方法称为分派调用，是在运行期才能确定正确的目标方法，得到直接引用。而分派调用又分为静态分派和动态分派。</p><h2 id="分派调用"><a class="header-anchor" href="#分派调用">¶ </a>分派调用</h2><p>分派都是通过方法的符号引用去运行时常量池中去查找得到方法所属类型（即调用该方法的引用变量所属类型，是静态类型）及方法名和描述符，然后根据方法名和描述符去所属类型的方法表中查找确定该方法的目标版本，进而得到方法的直接引用。</p><h3 id="静态分派"><a class="header-anchor" href="#静态分派">¶ </a>静态分派</h3><p>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。</p><p>在 Java 中的体现就是方法重载，在编译阶段，编译器会根据参数的静态类型决定使用哪个重载版本，完全发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。只是在运行期间去静态类型的方法表中查找该方法，从而得到该方法的直接引用。</p><h3 id="动态分派"><a class="header-anchor" href="#动态分派">¶ </a>动态分派</h3><p>相对于静态分派，动态分派是在运行期根据实际类型来确定方法执行版本的分派过程称为动态分派。</p><p>在 Java 中的体现就是方法的覆写。因为实际类型在运行期间可随着程序变化，因此只能在在运行期间才能确定一个对象的实际类型是什么，编译时编译器并不知道，只知道静态类型是什么。那就需要动态的分派目标方法执行版本。这个过程就是重写的本质</p><p>但是针对 invokevirtual 和 invokeinterface 两个指令，动态分派的具体过程是不同的：</p><ul><li>invokevirtual，实例调用，调用对象的实例方法。动态的分派目标方法执行版本是先在静态类型方法表中找到目标方法并得到偏移量，根据栈帧中对象的引用得到这个对象，在从对象中指向方法区类信息和运行时常量池的引用得到对象的实际类型的类信息，然后在得到的类信息方法表相同偏移量的位置查找目标方法</li><li>invokeinterface, 接口方法调用，在运行时再确定一个实现此接口的对象。因为一个类可以实现多个接口，相当于多继承。所以就不能按照偏移量去实现类的方法表中查找了，只能通过搜索完整的方法表。</li></ul><p>不管是动态分派还是静态分派，我们发现都离不开一个关键的东西<strong>方法表</strong>，最终都是通过方法表进行索引从而得到方法的直接引用。因此方法表是实现动态分派的一个关键。</p><h2 id="方法表"><a class="header-anchor" href="#方法表">¶ </a>方法表</h2><p>JVM 在完成类加载后，会将这个 class 文件二进制字节流转化为虚拟机所需格式存储在方法区中，称为类信息，类信息就是类文件在运行时的数据结构，包含了该类中所有定义的信息。</p><p>类信息中包含有一个方法表，方法表中包括从父类（一直到 Object 类）继承的所有实例方法（不包含私有方法，因为私有方法不能继承）以及自身覆写的方法的直接引用，这些直接引用指向类信息中相应的方法代码。</p><p>如果是本类的方法或者是覆写了父类的方法，则指向的是本类类信息中相应的方法代码；如果是父类的方法，则指向的是父类类信息中的方法代码。这样通过方法表中方法的引用就可以访问到该类到根类的所有实例方法。</p><p>方法表是 JVM 用来提高搜索查找目标方法性能的一个实现。invokevirtual 执行时用到的方法表是虚方法；invokeinterface 用到的方法表是接口方法表。为了程序上实现的方便，具有相同签名的方法，在父类、子类的虚方法表中都具有一样的索引号，因此才可直接使用偏移量在实际类型的方法表中进行查找。</p><h2 id="多态"><a class="header-anchor" href="#多态">¶ </a>多态</h2><p>那么什么是多态呢，一般的书籍都是把多态分为两种：</p><ul><li>编译时多态，通过方法的重载体现，是静态分派</li><li>运行时多态，通过方法的覆写体现，是动态分派</li></ul><p>因为重载是静态分派，因此也可以说重载不算是多态的一个体现，但并不妨碍我们的理解。</p><p>多态还可以从不同的角度进行定义，如在语法上是子类继承父类并覆写了父类的方法，父类引用指向子类对象。在 OOP 里是 Java 引入了多态性的概念是为了弥补因为单继承而带来的一些不足，如接口也是在一定程度上为了可以使用多继承。</p><p>另外重载和覆写说的都是方法，只有类中的方法才有多态的概念，类中的成员变量和内部类并没有此概念。静态方法也没有多态的概念，和成员变量取值与父类还是子类一样，都是由引用变量的静态类型决定的。也因此可以说静态方法并不能被覆写。</p><h2 id="参考"><a class="header-anchor" href="#参考">¶ </a>参考</h2><p>内容主要来自 《深入理解 Java 虚拟机》第八章。都是自己理解后总结的，难免有错误之处，以后慢慢修正。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 之常量池</title>
      <link href="2017/09/30/JVM-CP/"/>
      <url>2017/09/30/JVM-CP/</url>
      
        <content type="html"><![CDATA[<p>最近在看周志明的《深入理解 Java 虚拟机》这本书，不得说，学习 JVM 对更深层次理解 Java 有很大的帮助，两者互相印证。像打通了任督二脉一般，对 OOP 和 语法这块为什么要这么设计，语法为什么要这么写豁然开朗，融汇贯通后也更便于记忆这些知识点。</p><p>文章大多摘自自己的 Wiki <a href="https://github.com/HackerOO7/hackeroo7.github.com/wiki/Java-Basic" target="_blank" rel="noopener">JavaBasic</a>，都是对知识点的总结，加上自己的理解后一条条写下的。难免有很多理解错误的地方，自己前前后后也纠正了不少，也是一个学习的过程。</p><p>关于常量池这块，本来就知道一个字符串常量池，可是看了 JVM 后，又冒出了好几个常量池，顿时懵逼了。看了大量资料，理解后总结出了这么点知识。</p><a id="more"></a><h2 id="常量池的划分"><a class="header-anchor" href="#常量池的划分">¶ </a>常量池的划分</h2><ul><li>Class 文件常量池</li><li>运行时常量池</li><li>字符串常量池</li></ul><h3 id="class-文件常量池"><a class="header-anchor" href="#class-文件常量池">¶ </a>Class 文件常量池</h3><p>Class 文件常量池指的是编译生成的 class 字节码文件，其结构中有一项是常量池（Constant Pool Table），用于存放编译期生成的各种<strong>字面量</strong>和<strong>符号引用</strong>，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>什么是字面量和符号引用呢，为了理解这两个概念，只能啰嗦的写了。</p><ul><li>这里的字面量是指字符串字面量和声明为 final 的（基本数据类型）常量值，这些字符串字面量除了类中所有双引号括起来的字符串(包括方法体内的)，还包括所有用到的类名、方法的名字和这些类与方法的字符串描述、字段(成员变量)的名称和描述符；声明为final的常量值指的是成员变量，不包含本地变量，本地变量是属于方法的。这些都在常量池的 UTF-8 表中(逻辑上的划分)</li><li>符号引用，就是指指向 UTF-8 表中向这些字面量的引用，包括类和接口的全限定名(包括包路径的完整名)、字段的名称和描述符、方法的名称和描述符。只不过是以一组符号来描述所引用的目标，和内存并无关，所以称为符号引用，直接指向内存中某一地址的引用称为直接引用</li></ul><h3 id="运行时常量池"><a class="header-anchor" href="#运行时常量池">¶ </a>运行时常量池</h3><p>运行时常量池是方法区的一部分，是一块内存区域。Class 文件常量池将在类加载后进入方法区的运行时常量池中存放。</p><p><s>一个类加载到 JVM 中后对应一个运行时常量池</s>，运行时常量池相对于 Class 文件常量池来说具备动态性，Class 文件常量只是一个静态存储结构，里面的引用都是符号引用。而运行时常量池可以在运行期间将符号引用解析为直接引用。</p><p>可以说运行时常量池就是用来索引和查找字段和方法名称和描述符的。给定任意一个方法或字段的索引，通过这个索引最终可得到该方法或字段所属的类型信息和名称及描述符信息，这涉及到方法的调用和字段获取。</p><h3 id="字符串常量池"><a class="header-anchor" href="#字符串常量池">¶ </a>字符串常量池</h3><ul><li>在 jdk1.6（含）之前也是方法区的一部分，并且其中存放的是字符串的实例</li><li>在 jdk1.7（含）之后，是在堆内存之中，存储的是字符串对象的引用，字符串实例是在堆中</li><li>jdk1.8 已移除永久代，字符串常量池是在本地内存当中，存储的也只是引用</li></ul><p><strong>字符串常量池是全局</strong>的，JVM 中独此一份，因此也称为全局字符串常量池。</p><p>运行时常量池中的字符串字面量若是成员的，则在类的加载初始化阶段就使用到了字符串常量池；若是本地的，则在使用到的时候（执行此代码时）才会使用到字符串常量池。</p><p>其实，“使用常量池”对应的字节码是一个 <code>ldc</code> 指令，在给 String 类型的引用赋值的时候会先执行这个指令，看常量池中是否存在这个字符串对象的引用，若有就直接返回这个引用，若没有，就在堆里创建这个字符串对象并在字符串常量池中记录下这个引用（jdk1.7)。String 类的 <code>intern()</code> 方法还可在运行期间把字符串放到字符串常量池中。</p><p>JVM 中除了字符串常量池，8种基本数据类型中除了两种浮点类型剩余的6种基本数据类型的包装类，都使用了缓冲池技术，但是 Byte、Short、Integer、Long、Character 这5种整型的包装类也只是在对应值在 [-128,127] 时才会使用缓冲池，超出此范围仍然会去创建新的对象。</p><h2 id="总结"><a class="header-anchor" href="#总结">¶ </a>总结</h2><p>理解了这部分后，后面才能更容易的理解 JVM 中方法的调用，多态的实现等。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 常量池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 安全引导机制分析和绕过测试</title>
      <link href="2017/09/30/Bypass-QCOM-Secure-Boot/"/>
      <url>2017/09/30/Bypass-QCOM-Secure-Boot/</url>
      
        <content type="html"><![CDATA[<p>上半年为了学位写了一篇论文，今天把它转成了 markdown 格式，便于分享。全文在我的 <a href="https://github.com/HackerOO7/hackeroo7.github.com/wiki/Bypass-QCOM-Secure-Boot" target="_blank" rel="noopener">Wiki里</a>，算是全文吧，去除了很多论文必须的废话。并把其中的干货拿出来放到这里。</p><p>文章对高通的安全引导机制进行了简单分析，并在小米一款机器上综合漏洞成功绕过了其安全引导机制,达到自由修改系统分区的目的。</p><a id="more"></a><h2 id="android安全引导流程和组成"><a class="header-anchor" href="#android安全引导流程和组成">¶ </a>Android安全引导流程和组成</h2><h3 id="android安全引导流程"><a class="header-anchor" href="#android安全引导流程">¶ </a>Android安全引导流程</h3><p>一台 Android 设备是由硬件和软件组成，当按下开机键时系统从硬件到软件，在到最后进入 Android 系统，是一个完成的引导过程。以高通为例，在一个常规的引导过程中，CPU 引导芯片代码 PBL（Primary Boot Loader，类似于 x86 的 BIOS，有时也被成为 BootROM）从预定义的地方（固化在 ROM）开始执行，PBL由高通做好后烧写在芯片中，不可更改，是 RoT（Root of Trust，信任根）。使用烧录在fuse中的根公钥校验并加载引导程序 SBL1（Secondary Boot Loader），跳转到 sbl1 执行，SBL1 加载校验 APPSBL（aboot），最后 APPSBL 加载校验 boot 分区<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。内核启动后，会通过内核中的 dm-verity<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> 功能模块校验系统分区的完整性。这样就完成了整个系统的安全引导。整个流程如图所示<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>：</p><p><img src="/media/image2.png" alt="secureboot_flow" title="安全引导流程"></p><p>目前 Android 一个完整的校验过程，分为两部分：</p><ol><li><p>一分部是官方的 verified boot，由内核中的 dm-verity 来确保 system 分区没有经过被篡改</p></li><li><p>另一部分是针对于不同设备的引导加载程序的安全引导来验证最终 boot 镜像的完整性。这两部分共同建立了一个从 bootloader 到系统镜像的信任校验链</p></li></ol><h3 id="android安全引导组成"><a class="header-anchor" href="#android安全引导组成">¶ </a>Android安全引导组成</h3><h4 id="引导加载程序的安全引导"><a class="header-anchor" href="#引导加载程序的安全引导">¶ </a>引导加载程序的安全引导</h4><p>这个过程是一个安全认证校验链，都是由上一阶段的程序加载校验下一阶段的要执行的程序，通过签名校验机制，来确保系统不被经过任何形式的篡改，只执行制造商的固件。此过程是特定于设备的，通常通过使用不可更改的特定于硬件的密钥来实现被“烧录”（写入只写存储器）到设备中。该密钥用于验证每级的引导加载程序到最终boot镜像的完整性。</p><p>高通的 bootloader 是开源项目，在 Android 代码树的 <code>bootable/bootloader/lk</code> 下可以看到它的代码。是针对特定的主板与芯片编写的，并不是Android操作系统的一部分。由于 SBL 代码是闭源代码，分析起来是一个复杂的过程。论文在分析研究引导加载程序的安全引导过程中只从 APPSBL 开始进行分析。</p><p>Bootloader 是 OEM 厂商或者运营商加锁和限制的地方。当 bootloader 上锁后就不允许在非解锁状态下对手机固件进行修改或者刷第三方系统。这些限制取决于 OEM 和运营商的具体决策，可能会有所不同，但普遍都会采用密码学的签名校验机制来阻止设备被刷机或者执行未经合法签名的代码。如果用户想要刷机就需要先对 bootloader 进行解锁。现 OEM 都会采用专门的机制，比如需向官方申请解锁码，申请通过后得到解锁码才可以解锁设备。设备解锁后 bootloader 将不再对 boot 和 recovery 分区进行签名校验，也就是不在进行安全引导，允许进行刷机和清除用户数据等操作。</p><p>后面的章节还将会针对高通的 LK 的签名和校验<br>机制进行解剖分析，研究具体的安全保护措施，分析存在的安全缺陷和隐患。</p><h4 id="verified-boot"><a class="header-anchor" href="#verified-boot">¶ </a>Verified Boot</h4><p>从版本 4.4 起，Android 支持使用 Linux 的 Device-Mapper<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup> 框架中的 dm-verity 功能进行验证启动。Dm-verity 是为块完整性检查而设计开发，使用加密散列树提供块设备的透明完整性检查。它可以验证每个设备块在从磁盘读取时的完整性，如果块检出，则读取成功;<br>如果没有，读取会产生 I/O 错误，就好像块被实际损坏了一样。在 Android 中用来保护系统重要分区如 system 分区或 vendor 分区的完整性。系统分区被挂载为只读模式，不再允许被挂载为读写模式。校验系统分区时使用的密钥在 boot 镜像的 ramdisk 中。</p><p>论文后面的章节还将会继续分析 Verified Boot 在 Android 上的具体实现，研究存在的安全缺陷和隐患。</p><h2 id="android安全引导机制及缺陷分析"><a class="header-anchor" href="#android安全引导机制及缺陷分析">¶ </a>Android安全引导机制及缺陷分析</h2><h3 id="引导加载程序引导机制分析"><a class="header-anchor" href="#引导加载程序引导机制分析">¶ </a>引导加载程序引导机制分析</h3><h4 id="user-keystore校验漏洞挖掘"><a class="header-anchor" href="#user-keystore校验漏洞挖掘">¶ </a>user keystore校验漏洞挖掘</h4><p>Bootloader 序是一种专门的，特定于硬件的程序，当设备首次通电（ARM 设备复位时）执行。其目的是初始化设备硬件，提供最小的设备配置接口，然后找到并启动操作系统。引导设备通常需要经历不同的阶段，这涉及每个阶段的单独的引导加载程序，本文只分析 APPSBL（aboot）加载引导程序。Android 引导加载程序通常是专有的，特定于芯片 SoC 的系统。设备和 SoC 制造商在其引导加载程序中提供不同的功能和级别的保护。</p><p>在整个校验链中由aboot来提供验证 boot.img 的完整性，其开源代码 LK 可在 Code Aurora Forum 下载。在 LK 中有两个可用于校验的不同的密钥：</p><ul><li><p>一个是 <code>oem_keystore</code>，被编译到 aboot 中，定义在 <code>platform/msm_shared/include/oem_keystore.h</code></p></li><li><p>一个是 <code>user_keystore</code> 存储在 keystore 分区中</p></li></ul><p>引导过程中始终尝试使用 OEM keystore 来验证 boot.img 和 recovery.img。但在 keystore 分区不为空的时候，会使用 OEM keystore 对其签名进行验证，如果验证通过，将从里面读取 <code>user_keystore</code>，然会用其验证 boot.img 和 recovery.img。</p><p><code>user_keystore</code> 包含了用于验证的 RSA 公钥。以 CAF 代码 <code>LA.BR.1.3.2_rb3.14</code>分支为例，整个基本函数和逻辑执行如图所示：</p><p><img src="/media/image3.png" alt="boot_verify_flow" title="bootimage 验证流程"></p><p>最终调用的 <code>verify_image_with_sig()</code> 采用的是 <code>user_keystore</code>中的公钥进行校验。而 <code>user_keystore</code> 的值由 <code>boot_verifier_init</code> 调用 <code>read_oem_keystore</code>，将<br><code>oem_keystore</code> 赋值 <code>user_keystore</code>。接着对 keystore 分区进行验证，如果验证通过，则将分区中的数据赋值 <code>user_keystore</code>。这样就完成了对 user<br>keystore 的利用。</p><p>但是 <code>read_user_keystor()</code> 方法中调用 <code>verify_keystore</code> 验证 user keystore 时，在 <code>if-else</code> 判断中的 385 行因缺少花括号，导致无论验证成功与否，都会 <code>user_keystore</code> 进行赋值。具体代码如图所示：</p><p><img src="/media/image4.png" alt="issue_code" title="问题代码"></p><p>这样就造成了一个明显的安全漏洞，user keystore 不用经过 OEM 的签名也可以用于校验 boot 或 recovery 镜像。我们只需要自己签名生成 keystore.img 通过其它漏洞写入手机就可以绕过安全引导机制。</p><h4 id="解锁标记位的保护分析"><a class="header-anchor" href="#解锁标记位的保护分析">¶ </a>解锁标记位的保护分析</h4><p>在高通的分区表中，有一个名为 devinfo 的分区，大小 1024K。在 <code>app/aboot/devinfo.h</code> 中定义了其数据结构，包括了 <code>is_unlocked</code> 解锁状态标记位；<code>is_tampered</code> 篡改标记位等。通过 <code>fastboot oem device-info</code> 命令可以获取相关信息。</p><p>在 LK 启动时，通 <code>aboot\_init()-&gt;read_device_info(&amp;device)-&gt;read_device_info_mmc()</code> 读取，若 <code>is_unlock</code> 为 true，就跳过校验，允许执行 flash 命令等。使用 <code>fastboot oem unlock</code> 命令后，会通过 <code>write_device_info_mmc(&amp;device)</code> 对 devinfo 分区的标记位进行操作。</p><p>高通源代码中并为对该标记位进行加密签名等保护，直接修改标记位就可以使用对手机的解锁。但是在 OEM 的实现中，大多都会对该分区进行保护，修改分区名和使用加密签名等手段，保证分区不被非法篡改。</p><p>但 Android 碎片化的存在，厂商技术的参差不齐，依然有很多设备未对该部分进行修改，留下了安全漏洞。</p><h4 id="高通下载模式分析"><a class="header-anchor" href="#高通下载模式分析">¶ </a>高通下载模式分析</h4><p>高通有着自己的下载协议，一般在设备生产的时候通过该协议烧录固件。在 lk 代码 <code>aboot_init</code> 中，通过监控按键等操作可以选择到进入到不同的模式，如 recovery 或<br>fastboot 模式等。代码中默认当同时按下音量上下键时，则进入到 DLOAD 模式，也就是下载模式。然后通过高通专有的 sahara 或 firehose 协议工具进行固件的下载更新<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>。</p><p>同样在 <code>kernel/drivers/power/reset/msm-poweroff.c</code> 中相关代码由宏 <code>CONFIG_MSM_DLOAD_MOD</code> 控制，可开启或关闭是否可以通过  <code>adb reboot edl/dload</code> 命令重启进入到下载模式。</p><p>高通的升级工具及协议在下载的过程中，并不会对固件进行任何的校验，如果下载了错误或损坏的固件，则直接会让设备变砖。但是，厂商为方便开发、生产、售后等需求，并不会完全关闭掉高通的下载模式，有的会留下隐蔽的接口来进入到该模式。</p><h3 id="android的verified-boot"><a class="header-anchor" href="#android的verified-boot">¶ </a>Android的Verified Boot</h3><h4 id="dm-verity概述"><a class="header-anchor" href="#dm-verity概述">¶ </a>Dm-verity概述</h4><p>Dm-verity 使用加密散列树提供块设备的透明完整性检查，每个块以 4k 的大小来划分，都有一个 SHA256 的值。树中的每个节点是加密 hash，其中叶节点包含物理数据块的 hash，并且中间节点包含其子节点的 hash。因为根节点中的哈希是基于所有其他节点的值，所以只有根哈希需要被信任才能验证树的其余部分。对任何一个节点块的改动都破坏整个加密 hash。整个哈希树的结构如图所示：</p><p><img src="/media/image5.png" alt="dm-verity_hash-tree" title="哈希树"></p><p>验证时使用包含在 boot 分区中的 RSA 公钥来执行。设备块在运行时通过计算读取的块的哈希值并将其与散列树中的记录值进行比较来检查。如果值不匹配，则读取操作将导致 I/O 错误，指示文件系统已损坏。因为所有的检查都是由内核执行的，所以启动过程需要验证 boot.img 的完整性，以便验证引导工作。</p><p>在 Android 中被校验的分区始终挂载为只读状态，只能在 OTA 块设备升级时才可做更改。其它任何对分区的操作都会破坏分区的完整性，比如 root 等操作。</p><h4 id="在android中的实现方法"><a class="header-anchor" href="#在android中的实现方法">¶ </a>在Android中的实现方法</h4><p>Dm-verity device-mapper 目的最初是为了在 Chrome 操作系统中实现验证启动而开发的，并且已经在 Linux 内核的 3.4 版本中集成。它使用 <code>CONFIG_DM_VERITY</code> 内核配置项来进行开关。</p><p>但 Android 的具体实现方式和 Chrome 有所不同。用于验证的 RSA 公钥在 boot 镜像的 ramdisk 中，文件名是 <code>verity_key</code>，用于验证目标设备的 root<br>hash 签名。被验证的目标分区，有着一个包含了哈希表和它自身签名的元数据块，被附加到镜像的最后。如果要启用对某一分区的校验，需要在 ramdisk 中的 fstab 文件中对特定设备添加 verify 标签<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>。</p><p>当系统启动过程中，检测到该标签，则会使用 <code>verity_key</code> 公钥加载校验该分区最后附加的元数据。如果签名验证通过，则文件系统管理器解析 dm-verity 映射表，并将其传递给 Linux 设备映射器，设备映射器使用映射表中包含的信息来创建虚拟的 dm-verity 块设备。然后将该虚拟块设备安装在 fstab 中指定的安装点上，代替相应的物理设备。因此，所有读自底层物理设备的数据都会用预先生成的散列树进行透明验证。对设备任何修改或添加文件，甚至将分区重新挂载为读写都会导致完整性验证和 I/O 错误。虚拟设备的挂载如图所示：</p><p><img src="/media/image6.png" alt="dm-verity-virutal-block-device-mounted" title="虚拟设备"></p><p>但是因为具体的实现方式原因，用于校验的 RSA 公钥 <code>verity_key</code>，直接被放在了 ramdisk中。这给了替换该公钥文件进行攻击的可能性。而且对目标设备是否进行校验，也直接用明 verify 签进行判断，这也是一个明显的安全缺陷。</p><h4 id="启用verified-boot"><a class="header-anchor" href="#启用verified-boot">¶ </a>启用Verified Boot</h4><p>在谷歌的官方文档描述中，要完全启用 verified boot，除了要配置整个编译系统开启相关选项，还需要引导加载程序实现相关对boot镜像的完整性校验。上节已经针对高通 SoC 在这块的实现进行了分析研究。</p><p>AOSP 源代码中，开发 key 包括公钥和私钥，它们位 <code>build/target/product/security/</code> 目录。用来给 boot/recovery/system 镜像签名，以及验证 system 分区的真实性元数据块表<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>。在启用 verified boot 时需要生成自己的公私钥，但某些机型设备依然是使用的默认的密钥，这相当于是导致了密钥的泄露，对设备来说没有任何安全性可言了。</p><h2 id="漏洞利用测试和安全加固"><a class="header-anchor" href="#漏洞利用测试和安全加固">¶ </a>漏洞利用测试和安全加固</h2><h3 id="利用漏洞绕过安全引导"><a class="header-anchor" href="#利用漏洞绕过安全引导">¶ </a>利用漏洞绕过安全引导</h3><h4 id="攻击方法的设计"><a class="header-anchor" href="#攻击方法的设计">¶ </a>攻击方法的设计</h4><p>在上一章中分析了存在安全缺陷和漏洞。利用自签名的 user keystore 和 boot/recovery 镜像，并且在 boot 的 ramdis k中移除对 system 分区的进行校验的 verify 标记。或者替换 ramdisk 中的verity_key，并对 system 镜像进行签名。刷写到手机中，就能实现绕过某些机型的安全引导机制，对设备进行自由修改。</p><p>但是在设备处于 LOCKED 状态时，是无法通过 fastboot 进行刷写操作的。但是 OEM 一般都会预留自己的下载模式，比如三星的 ODIN，联发科的 SP Flashtool。而高通 SoC 则是上一章中分析到的 dload/edl 模式，该模式在固件镜像下载过程中并不做任何的校验，直接能刷写进去。</p><p>本文测试机器是 红米Note3 全网通版，系统的版本为 V7.2.3.0，Android 版本 6.0,内部开发代号 kenzo。Kenzo 在几次的升级后，逐渐关闭了按键进入，<code>adb reboot dload/edl</code> 重启进入下载模式的途经，开启了 dm-verity，来保护手机不被破解和刷机。但是通过IDA<br>Pro逆向分析 aboot 分区中的 emmc_appsboot.mbn 引导加载程序镜像时，发现了 <code>reboot-edl</code>的命令。如图所示：</p><p><img src="/media/image7.png" alt="reboot-edl_ command" title="小米自己添加的命令"></p><p>正如其命名一样，是标准 fastboot 协议是不支持此命令的，为此需要修改 fastboot 源码。fastboot 源代码在 AOSP 源码树  <code>system/core/fastboot</code> 中。分析 fastboot 源码，命令最后是通过 <code>fb_queue_command</code> 发送给 bootloader，修改代码添加对该命令的支持。然后就能成功的重启到 edl 模式。核心代码示例如图所示：</p><p><img src="/media/image8.png" alt="code" title="添加命令支持"></p><h4 id="漏洞利用测试过程"><a class="header-anchor" href="#漏洞利用测试过程">¶ </a>漏洞利用测试过程</h4><p>整个测试过程是为了验证本文对安全引导机制进行分析研究后挖掘出的相关安全漏洞，达到在设备处于 LOCKED 状态时，篡改并修改设备，绕过 Android 安全引导机制。过程如下：</p><ol><li><p>生成自己的公私钥对</p></li><li><p>利用公私钥对生成并签名 keystore.img</p></li><li><p>对 boot.img 重新打包，移除 system 分区 verify flag</p></li><li><p>对 boot.img 进行重新签名</p></li><li><p>使用修改后的 fastboot，执行<code>fastboot reboot-edl</code>进入下载模式</p></li><li><p>使用 emmcdl<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup> 工具分别刷入 keystore.img boot.img</p></li></ol><p>若设备能成功开启，则证明完全绕过了 Android 的安全引导机制。System 分区也不在不挂载为虚拟设备，而是真实的物理设备块。如图所示：</p><p><img src="/media/image9.png" alt="屏幕快照 2017-03-24 20.05.29" title="真实设备的挂载"></p><p>在手机预装行业中，还会对 system 分区镜像进行篡改，然后利用上面的过程也刷写到手机中。同样也可以修改 devinfo 分区的标记位，强制修改手机的状态。这样有了一套对该机型进行刷机预装的方案。</p><h2 id="参考"><a class="header-anchor" href="#参考">¶ </a>参考</h2><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://security.tencent.com/index.php/blog/msg/38" target="_blank" rel="noopener">Tecent. Android系统典型bootloader分析</a> <a href="#fnref1" class="footnote-backref">↩</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://code.google.com/p/cryptsetup/wiki/DMVerity" target="_blank" rel="noopener">Milan Broz. dm-verity: device-mapper block integrity checking target</a> <a href="#fnref2" class="footnote-backref">↩</a></p></li><li id="fn3" class="footnote-item"><p><a href="http://bits-please.blogspot.jp/2016/02/unlocking-motorola-bootloader.html" target="_blank" rel="noopener">laginimaineb. Unlocking the Motorola Bootloader</a> <a href="#fnref3" class="footnote-backref">↩</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://www.sourceware.org/dm/" target="_blank" rel="noopener">Red Hat Inc. Device-Mapper Resource Page</a> <a href="#fnref4" class="footnote-backref">↩</a></p></li><li id="fn5" class="footnote-item"><p><a href="http://blog.csdn.net/fybon/article/details/37565227" target="_blank" rel="noopener">CSDN. 高通 MSM8K bootloader 之二：SBL1</a> <a href="#fnref5" class="footnote-backref">↩</a></p></li><li id="fn6" class="footnote-item"><p><a href="http://source.android.com/devices/tech/security/dm-verity.html" target="_blank" rel="noopener">Google. dm-verity</a> <a href="#fnref6" class="footnote-backref">↩</a></p></li><li id="fn7" class="footnote-item"><p><a href="http://blog.csdn.net/a04081122/article/details/53522705" target="_blank" rel="noopener">CSDN. QualComm Android boot recovery vertify</a> <a href="#fnref7" class="footnote-backref">↩</a></p></li><li id="fn8" class="footnote-item"><p><a href="https://github.com/binsys/emmcdl" target="_blank" rel="noopener">Github. emmcdl</a> <a href="#fnref8" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Secure Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>少了一条腿的大蜘蛛</title>
      <link href="2017/09/29/Shamballa-hike-photo/"/>
      <url>2017/09/29/Shamballa-hike-photo/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/mjfObX6.jpg" alt="尸横遍野"></p><blockquote><p>少了一条腿的大蜘蛛，摄于九月中旬西山香巴拉中途</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 相册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 西山 </tag>
            
            <tag> 香巴拉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开始使用 Hexo</title>
      <link href="2017/09/28/migrate-to-hexo-md/"/>
      <url>2017/09/28/migrate-to-hexo-md/</url>
      
        <content type="html"><![CDATA[<p>这几天看到一个主题，自己非常中意。</p><p>一看是 Hexo 下的，早前就想切到这个框架下，但拖延症严重，一直未动手。恰好赶上这个时机，自己又闲来无事，遂动手。</p><p>都是些琐碎的配置工作，自己的文章又不多，索性一篇篇的来修改，又把以前没注意的一些排版上的问题给纠正下。主要添加了一个以前没接触过的 leancloud 的统计。</p><a id="more"></a><p>把以前感觉略中二的博客名字也改了，改为 Sunyata, 中文译文 “空性” 倒是和守望先锋里的和尚禅雅塔发音相似，意思也相近。</p><p>不过 Disqus 的评论给丢了，本就不多，有时间就迁移过来。</p>]]></content>
      
      
      <categories>
          
          <category> 记事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用一加3做 WIFI 中继器</title>
      <link href="2017/04/18/oneplus3-as-wifi-repeater/"/>
      <url>2017/04/18/oneplus3-as-wifi-repeater/</url>
      
        <content type="html"><![CDATA[<p>隔壁学校的 wifi 网络不错，但是因为离得远，信号差，只能在窗户边能连得上。买了一个 360 wifi 中继器，但速度掉的厉害，而用手机直接连接网速倒是正常，就想着把手机作为 wifi 中继器。记得自己的第一台 android 手机，中兴 v880 当时是支持 wifi 中继的，一边连着 wifi，一边扩展 wifi 信号，后来才知道那算是中兴特有的。找了一圈，并没有找到这样的 APP，fqrouter2 倒是有这个功能，但是作者已经停止维护，在我手机上直接启动失败。参考 fqrouter2 的文章和脚本终于让 oneplus3 STA+AP 一起工作了。</p><h2 id="使用一加3做-wifi-中继器脚本配置"><a class="header-anchor" href="#使用一加3做-wifi-中继器脚本配置">¶ </a>使用一加3做 wifi 中继器脚本配置</h2><ul><li>ONEPLUS A3000</li><li>系统 cm-13.0, Android 6.0.1</li><li>root 权限</li><li>iw iwlist wpa_cli 等二进制文件</li></ul><a id="more"></a><p>一加3 采用的是<a href="https://www.qualcomm.com/products/vive/chipsets" target="_blank" rel="noopener">QCA6164A</a> wifi 芯片，支持 802.11ac，最高有 434M 带宽。</p><p>系统本身自带的便携式 WLAN 热点功能，只能分享移动数据的网络，不能够做为一个 wifi repeater，开启时自动关闭 wifi 连接和 wpa_supplicant进程，并开启 hostapd 进程来提供 AP。 但系统支持 <a href="https://developer.android.com/training/connect-devices-wirelessly/wifi-direct.html" target="_blank" rel="noopener">WIFI Direct</a> 功能，也就是说设备在连接着 wifi 的时，可以开启一个热点，其它设备可以通过这个热点加入到 P2P group 中。但是 WIFI Direct 不支持手动设置密码，连接外网等。</p><p>查看网卡设备信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line">root@oneplus3:/data/local/tmp # iw phy</span><br><span class="line">Wiphy phy3</span><br><span class="line">    max # scan SSIDs: 10</span><br><span class="line">    max scan IEs length: 500 bytes</span><br><span class="line">    max # sched scan SSIDs: 0</span><br><span class="line">    max # match sets: 0</span><br><span class="line">    Retry short limit: 7</span><br><span class="line">    Retry long limit: 4</span><br><span class="line">    Coverage class: 0 (up to 0m)</span><br><span class="line">    Device supports roaming.</span><br><span class="line">    Device supports T-DLS.</span><br><span class="line">    Supported Ciphers:</span><br><span class="line">        * WEP40 (00-0f-ac:1)</span><br><span class="line">        * WEP104 (00-0f-ac:5)</span><br><span class="line">        * TKIP (00-0f-ac:2)</span><br><span class="line">        * 00-40-96:254</span><br><span class="line">        * 00-40-96:255</span><br><span class="line">        * CCMP-128 (00-0f-ac:4)</span><br><span class="line">        * WPI-SMS4 (00-14-72:1)</span><br><span class="line">        * CMAC (00-0f-ac:6)</span><br><span class="line">    Available Antennas: TX 0 RX 0</span><br><span class="line">    Supported interface modes:</span><br><span class="line">         * IBSS</span><br><span class="line">         * managed</span><br><span class="line">         * AP</span><br><span class="line">         * P2P-client</span><br><span class="line">         * P2P-GO</span><br><span class="line">    Band 1:</span><br><span class="line">        Capabilities: 0x9072</span><br><span class="line">            HT20/HT40</span><br><span class="line">            Static SM Power Save</span><br><span class="line">            RX Greenfield</span><br><span class="line">            RX HT20 SGI</span><br><span class="line">            RX HT40 SGI</span><br><span class="line">            No RX STBC</span><br><span class="line">            Max AMSDU length: 3839 bytes</span><br><span class="line">            DSSS/CCK HT40</span><br><span class="line">            L-SIG TXOP protection</span><br><span class="line">        Maximum RX AMPDU length 65535 bytes (exponent: 0x003)</span><br><span class="line">        Minimum RX AMPDU time spacing: 16 usec (0x07)</span><br><span class="line">        HT Max RX data rate: 72 Mbps</span><br><span class="line">        HT TX/RX MCS rate indexes supported: 0-7</span><br><span class="line">        Bitrates (non-HT):</span><br><span class="line">            * 1.0 Mbps</span><br><span class="line">            * 2.0 Mbps</span><br><span class="line">            * 5.5 Mbps</span><br><span class="line">            * 11.0 Mbps</span><br><span class="line">            * 6.0 Mbps</span><br><span class="line">            * 9.0 Mbps</span><br><span class="line">            * 12.0 Mbps</span><br><span class="line">            * 18.0 Mbps</span><br><span class="line">            * 24.0 Mbps</span><br><span class="line">            * 36.0 Mbps</span><br><span class="line">            * 48.0 Mbps</span><br><span class="line">            * 54.0 Mbps</span><br><span class="line">        Frequencies:</span><br><span class="line">            * 2412 MHz [1] (20.0 dBm)</span><br><span class="line">            * 2417 MHz [2] (20.0 dBm)</span><br><span class="line">            * 2422 MHz [3] (20.0 dBm)</span><br><span class="line">            * 2427 MHz [4] (20.0 dBm)</span><br><span class="line">            * 2432 MHz [5] (20.0 dBm)</span><br><span class="line">            * 2437 MHz [6] (20.0 dBm)</span><br><span class="line">            * 2442 MHz [7] (20.0 dBm)</span><br><span class="line">            * 2447 MHz [8] (20.0 dBm)</span><br><span class="line">            * 2452 MHz [9] (20.0 dBm)</span><br><span class="line">            * 2457 MHz [10] (20.0 dBm)</span><br><span class="line">            * 2462 MHz [11] (20.0 dBm)</span><br><span class="line">            * 2467 MHz [12] (20.0 dBm)</span><br><span class="line">            * 2472 MHz [13] (20.0 dBm)</span><br><span class="line">            * 2484 MHz [14] (disabled)</span><br><span class="line">    Band 2:</span><br><span class="line">        Capabilities: 0x9072</span><br><span class="line">            HT20/HT40</span><br><span class="line">            Static SM Power Save</span><br><span class="line">            RX Greenfield</span><br><span class="line">            RX HT20 SGI</span><br><span class="line">            RX HT40 SGI</span><br><span class="line">            No RX STBC</span><br><span class="line">            Max AMSDU length: 3839 bytes</span><br><span class="line">            DSSS/CCK HT40</span><br><span class="line">            L-SIG TXOP protection</span><br><span class="line">        Maximum RX AMPDU length 65535 bytes (exponent: 0x003)</span><br><span class="line">        Minimum RX AMPDU time spacing: 16 usec (0x07)</span><br><span class="line">        HT Max RX data rate: 72 Mbps</span><br><span class="line">        HT TX/RX MCS rate indexes supported: 0-7</span><br><span class="line">        VHT Capabilities (0x000003b2):</span><br><span class="line">            Max MPDU length: 11454</span><br><span class="line">            Supported Channel Width: neither 160 nor 80+80</span><br><span class="line">            RX LDPC</span><br><span class="line">            short GI (80 MHz)</span><br><span class="line">            TX STBC</span><br><span class="line">        VHT RX MCS set:</span><br><span class="line">            1 streams: MCS 0-7</span><br><span class="line">            2 streams: MCS 0-7</span><br><span class="line">            3 streams: MCS 0-7</span><br><span class="line">            4 streams: MCS 0-7</span><br><span class="line">            5 streams: MCS 0-7</span><br><span class="line">            6 streams: MCS 0-7</span><br><span class="line">            7 streams: MCS 0-7</span><br><span class="line">            8 streams: MCS 0-7</span><br><span class="line">        VHT RX highest supported: 0 Mbps</span><br><span class="line">        VHT TX MCS set:</span><br><span class="line">            1 streams: MCS 0-7</span><br><span class="line">            2 streams: MCS 0-7</span><br><span class="line">            3 streams: MCS 0-7</span><br><span class="line">            4 streams: MCS 0-7</span><br><span class="line">            5 streams: MCS 0-7</span><br><span class="line">            6 streams: MCS 0-7</span><br><span class="line">            7 streams: MCS 0-7</span><br><span class="line">            8 streams: MCS 0-7</span><br><span class="line">        VHT TX highest supported: 0 Mbps</span><br><span class="line">        Bitrates (non-HT):</span><br><span class="line">            * 6.0 Mbps</span><br><span class="line">            * 9.0 Mbps</span><br><span class="line">            * 12.0 Mbps</span><br><span class="line">            * 18.0 Mbps</span><br><span class="line">            * 24.0 Mbps</span><br><span class="line">            * 36.0 Mbps</span><br><span class="line">            * 48.0 Mbps</span><br><span class="line">            * 54.0 Mbps</span><br><span class="line">        Frequencies:</span><br><span class="line">            * 4920 MHz [184] (disabled)</span><br><span class="line">            * 4940 MHz [188] (disabled)</span><br><span class="line">            * 4960 MHz [192] (disabled)</span><br><span class="line">            * 4980 MHz [196] (disabled)</span><br><span class="line">            * 5040 MHz [8] (disabled)</span><br><span class="line">            * 5060 MHz [12] (disabled)</span><br><span class="line">            * 5080 MHz [16] (disabled)</span><br><span class="line">            * 5180 MHz [36] (23.0 dBm)</span><br><span class="line">            * 5200 MHz [40] (23.0 dBm)</span><br><span class="line">            * 5220 MHz [44] (23.0 dBm)</span><br><span class="line">            * 5240 MHz [48] (23.0 dBm)</span><br><span class="line">            * 5260 MHz [52] (23.0 dBm) (radar detection)</span><br><span class="line">            * 5280 MHz [56] (23.0 dBm) (radar detection)</span><br><span class="line">            * 5300 MHz [60] (23.0 dBm) (radar detection)</span><br><span class="line">            * 5320 MHz [64] (23.0 dBm) (radar detection)</span><br><span class="line">            * 5500 MHz [100] (disabled)</span><br><span class="line">            * 5520 MHz [104] (disabled)</span><br><span class="line">            * 5540 MHz [108] (disabled)</span><br><span class="line">            * 5560 MHz [112] (disabled)</span><br><span class="line">            * 5580 MHz [116] (disabled)</span><br><span class="line">            * 5600 MHz [120] (disabled)</span><br><span class="line">            * 5620 MHz [124] (disabled)</span><br><span class="line">            * 5640 MHz [128] (disabled)</span><br><span class="line">            * 5660 MHz [132] (disabled)</span><br><span class="line">            * 5680 MHz [136] (disabled)</span><br><span class="line">            * 5700 MHz [140] (disabled)</span><br><span class="line">            * 5720 MHz [144] (disabled)</span><br><span class="line">            * 5745 MHz [149] (30.0 dBm)</span><br><span class="line">            * 5765 MHz [153] (30.0 dBm)</span><br><span class="line">            * 5785 MHz [157] (30.0 dBm)</span><br><span class="line">            * 5805 MHz [161] (30.0 dBm)</span><br><span class="line">            * 5825 MHz [165] (30.0 dBm)</span><br><span class="line">            * 5852 MHz [170] (disabled)</span><br><span class="line">            * 5855 MHz [171] (disabled)</span><br><span class="line">            * 5860 MHz [172] (disabled)</span><br><span class="line">            * 5865 MHz [173] (disabled)</span><br><span class="line">            * 5870 MHz [174] (disabled)</span><br><span class="line">            * 5875 MHz [175] (disabled)</span><br><span class="line">            * 5880 MHz [176] (disabled)</span><br><span class="line">            * 5885 MHz [177] (disabled)</span><br><span class="line">            * 5890 MHz [178] (disabled)</span><br><span class="line">            * 5895 MHz [179] (disabled)</span><br><span class="line">            * 5900 MHz [180] (disabled)</span><br><span class="line">            * 5905 MHz [181] (disabled)</span><br><span class="line">            * 5910 MHz [182] (disabled)</span><br><span class="line">            * 5915 MHz [183] (disabled)</span><br><span class="line">            * 5920 MHz [184] (disabled)</span><br><span class="line">    Supported commands:</span><br><span class="line">         * new_interface</span><br><span class="line">         * set_interface</span><br><span class="line">         * new_key</span><br><span class="line">         * start_ap</span><br><span class="line">         * new_station</span><br><span class="line">         * set_bss</span><br><span class="line">         * join_ibss</span><br><span class="line">         * set_pmksa</span><br><span class="line">         * del_pmksa</span><br><span class="line">         * flush_pmksa</span><br><span class="line">         * remain_on_channel</span><br><span class="line">         * frame</span><br><span class="line">         * frame_wait_cancel</span><br><span class="line">         * set_channel</span><br><span class="line">         * tdls_mgmt</span><br><span class="line">         * tdls_oper</span><br><span class="line">         * testmode</span><br><span class="line">         * channel_switch</span><br><span class="line">         * connect</span><br><span class="line">         * disconnect</span><br><span class="line">    Supported TX frame types:</span><br><span class="line">         * IBSS: 0x00 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xa0 0xb0 0xc0 0xd0 0xe0 0xf0</span><br><span class="line">         * managed: 0x00 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xa0 0xb0 0xc0 0xd0 0xe0 0xf0</span><br><span class="line">         * AP: 0x00 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xa0 0xb0 0xc0 0xd0 0xe0 0xf0</span><br><span class="line">         * P2P-client: 0x00 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xa0 0xb0 0xc0 0xd0 0xe0 0xf0</span><br><span class="line">         * P2P-GO: 0x00 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xa0 0xb0 0xc0 0xd0 0xe0 0xf0</span><br><span class="line">    Supported RX frame types:</span><br><span class="line">         * IBSS: 0x00 0x20 0x40 0xa0 0xb0 0xc0 0xd0</span><br><span class="line">         * managed: 0x40 0xd0</span><br><span class="line">         * AP: 0x00 0x20 0x40 0xa0 0xb0 0xc0 0xd0</span><br><span class="line">         * P2P-client: 0x40 0xd0</span><br><span class="line">         * P2P-GO: 0x00 0x20 0x40 0xa0 0xb0 0xc0 0xd0</span><br><span class="line">    WoWLAN support:</span><br><span class="line">         * wake up on anything (device continues operating normally)</span><br><span class="line">         * wake up on disconnect</span><br><span class="line">         * wake up on magic packet</span><br><span class="line">         * wake up on pattern match, up to 4 patterns of 6-64 bytes,</span><br><span class="line">           maximum packet offset 0 bytes</span><br><span class="line">         * can do GTK rekeying</span><br><span class="line">         * wake up on GTK rekey failure</span><br><span class="line">         * wake up on EAP identity request</span><br><span class="line">         * wake up on 4-way handshake</span><br><span class="line">         * wake up on rfkill release</span><br><span class="line">    software interface modes (can always be added):</span><br><span class="line">    valid interface combinations:</span><br><span class="line">         * #&#123; managed &#125; &lt;= 3,</span><br><span class="line">           total &lt;= 3, #channels &lt;= 2</span><br><span class="line">         * #&#123; managed &#125; &lt;= 1, #&#123; IBSS &#125; &lt;= 1,</span><br><span class="line">           total &lt;= 2, #channels &lt;= 1</span><br><span class="line">         * #&#123; AP &#125; &lt;= 2,</span><br><span class="line">           total &lt;= 2, #channels &lt;= 2</span><br><span class="line">         * #&#123; P2P-client &#125; &lt;= 1, #&#123; P2P-GO &#125; &lt;= 1,</span><br><span class="line">           total &lt;= 2, #channels &lt;= 2</span><br><span class="line">         * #&#123; managed &#125; &lt;= 2, #&#123; AP &#125; &lt;= 1,</span><br><span class="line">           total &lt;= 3, #channels &lt;= 2, STA/AP BI must match</span><br><span class="line">         * #&#123; managed &#125; &lt;= 2, #&#123; P2P-client, P2P-GO &#125; &lt;= 2,</span><br><span class="line">           total &lt;= 4, #channels &lt;= 2, STA/AP BI must match</span><br><span class="line">         * #&#123; managed &#125; &lt;= 2, #&#123; P2P-GO &#125; &lt;= 1, #&#123; AP &#125; &lt;= 1,</span><br><span class="line">           total &lt;= 4, #channels &lt;= 2, STA/AP BI must match</span><br><span class="line">    Device supports HT-IBSS.</span><br><span class="line">    Device supports scan flush.</span><br></pre></td></tr></table></figure><p>该芯片是支持这些功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Supported interface modes:</span><br><span class="line">         * IBSS</span><br><span class="line">         * managed</span><br><span class="line">         * AP</span><br><span class="line">         * P2P-client</span><br><span class="line">         * P2P-GO</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@oneplus3:/ # iw dev</span><br><span class="line">phy#0</span><br><span class="line">    Interface p2p0</span><br><span class="line">        ifindex 24</span><br><span class="line">        wdev 0x2</span><br><span class="line">        addr c2:ee:fb:d6:08:0d</span><br><span class="line">        type managed</span><br><span class="line">    Interface wlan0</span><br><span class="line">        ifindex 23</span><br><span class="line">        wdev 0x1</span><br><span class="line">        addr c0:ee:fb:d6:08:0d</span><br><span class="line">        ssid BIUBIU_5G</span><br><span class="line">        type managed</span><br></pre></td></tr></table></figure><p>网卡有两个 interface，默认启用了 p2p 接口，但开启系统的热点功能后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@oneplus3:/ # iw dev</span><br><span class="line">phy#1</span><br><span class="line">    Interface wlan0</span><br><span class="line">        ifindex 27</span><br><span class="line">        wdev 0x100000001</span><br><span class="line">        addr c0:ee:fb:d6:08:0d</span><br><span class="line">        ssid ONEPLUS A3000</span><br><span class="line">        type AP</span><br></pre></td></tr></table></figure><p>p2p0 端口消失，只剩下了 wlan0 端口，查看 hostapd 进程的 cmdline</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@oneplus3:/ # cat /proc/11047/cmdline</span><br><span class="line">/system/bin/hostapd -e /data/misc/wifi/entropy.bin /data/misc/wifi/hostapd.conf</span><br></pre></td></tr></table></figure><p>先前的 wpa_supplicant 进程是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@oneplus3:/ # cat /proc/11257/cmdline</span><br><span class="line">/system/bin/wpa_supplicant -ip2p0- Dnl80211 -c/data/misc/wifi/p2p_supplicant.conf -I/system/etc/wifi/p2p_supplicant_overlay.conf -N -iwlan0 -Dnl80211 -c/data/misc/wifi/wpa_supplicant.conf -I/system/etc/wifi/wpa_supplicant_overlay.conf -O/data/misc/wifi/sockets -puse_p2p_group_interface=1 -e/data/misc/wi</span><br><span class="line">fi/entropy.bin</span><br></pre></td></tr></table></figure><p>wpa_supplicant 同时管理着 p2p0 wlan0 两个 interface，p2p0 interface 的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@oneplus3:/data/local/tmp # ./wpa_cli -p /data/misc/wifi/sockets/ -i p2p0 status</span><br><span class="line">wpa_state=DISCONNECTED</span><br><span class="line">p2p_device_address=c2:ee:fb:d6:08:0d</span><br><span class="line">address=c2:ee:fb:d6:08:0d</span><br><span class="line">uuid=4227ede7-6911-52a9-987c-6ce45048dfe1</span><br></pre></td></tr></table></figure><p>处于未连接状态，使用 <a href="https://android.googlesource.com/platform/external/wpa_supplicant_8/+/android-7.1.2_r6/wpa_supplicant/README-P2P" target="_blank" rel="noopener">wpa_cli</a> 直接添加一个固定的 p2p 分组， wpa_cli 支持交互模式。进行此操作之前，备份一下 <code>/data/misc/wifi/p2p_supplicant.conf</code>，防止出错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">root@oneplus3:/data/local/tmp # ./wpa_cli -p /data/misc/wifi/sockets/ -i p2p0</span><br><span class="line">wpa_cli v2.5-devel-6.0.1</span><br><span class="line">Copyright (c) 2004-2015, Jouni Malinen &lt;j@w1.fi&gt; and contributors</span><br><span class="line"></span><br><span class="line">This software may be distributed under the terms of the BSD license.</span><br><span class="line">See README for more details.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Interactive mode</span><br><span class="line"></span><br><span class="line">&gt; add_network</span><br><span class="line">0</span><br><span class="line">&gt; set_network 0 mode 3</span><br><span class="line">OK</span><br><span class="line">&gt; set_network 0 disabled 2</span><br><span class="line">OK</span><br><span class="line">&gt; set_network 0 ssid &quot;loopax&quot;</span><br><span class="line">OK</span><br><span class="line">&gt; set_network 0 key_mgmt WPA-PSK</span><br><span class="line">OK</span><br><span class="line">&gt; set_network 0 proto RSN</span><br><span class="line">OK</span><br><span class="line">&gt; set_network 0 pairwise CCMP</span><br><span class="line">OK</span><br><span class="line">&gt; set_network 0 psk &quot;12345678&quot;</span><br><span class="line">OK</span><br><span class="line">&gt; save_config</span><br><span class="line">OK</span><br><span class="line">&gt; list_network</span><br><span class="line">network id / ssid / bssid / flags</span><br><span class="line">0   loopax  any [DISABLED][P2P-PERSISTENT]</span><br><span class="line">&gt; p2p_group_add persistent=0</span><br><span class="line">OK</span><br><span class="line">&lt;3&gt;P2P-GROUP-STARTED p2p-p2p0-0 GO ssid=&quot;loopax&quot; freq=5765 passphrase=&quot;12345678&quot; go_dev_addr=c2:ee:fb:d6:08:0d [PERSISTENT]</span><br><span class="line">&gt; quit</span><br></pre></td></tr></table></figure><p>此时，热点就起来了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@oneplus3:/ # iw dev</span><br><span class="line">phy#3</span><br><span class="line">    Interface p2p-p2p0-0</span><br><span class="line">        ifindex 33</span><br><span class="line">        wdev 0x300000003</span><br><span class="line">        addr c2:ee:fb:d6:88:0d</span><br><span class="line">        ssid loopax</span><br><span class="line">        type P2P-GO</span><br><span class="line">    Interface p2p0</span><br><span class="line">        ifindex 32</span><br><span class="line">        wdev 0x300000002</span><br><span class="line">        addr c2:ee:fb:d6:08:0d</span><br><span class="line">        type managed</span><br><span class="line">    Interface wlan0</span><br><span class="line">        ifindex 31</span><br><span class="line">        wdev 0x300000001</span><br><span class="line">        addr c0:ee:fb:d6:08:0d</span><br><span class="line">        ssid BIUBIU_5G</span><br><span class="line">        type managed</span><br></pre></td></tr></table></figure><p>起来了一个新的接口 p2p-p2p0-0，type 是 P2P-GO, 该接口状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@oneplus3:/data/local/tmp # ./wpa_cli -p /data/misc/wifi/sockets/ -i p2p-p2p0-0 status</span><br><span class="line">bssid=c2:ee:fb:d6:88:0d</span><br><span class="line">freq=5765</span><br><span class="line">ssid=loopax</span><br><span class="line">id=0</span><br><span class="line">mode=P2P GO</span><br><span class="line">pairwise_cipher=CCMP</span><br><span class="line">group_cipher=CCMP</span><br><span class="line">key_mgmt=WPA2-PSK</span><br><span class="line">wpa_state=COMPLETED</span><br><span class="line">ip_address=192.168.49.1</span><br><span class="line">p2p_device_address=c2:ee:fb:d6:08:0d</span><br><span class="line">address=c2:ee:fb:d6:88:0d</span><br><span class="line">uuid=4227ede7-6911-52a9-987c-6ce45048dfe1</span><br></pre></td></tr></table></figure><p>热点可以正常连接，但是不能够上网，也 ping 不通 IP，开启设备的网络转发 和 NAT</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@oneplus3:/ # echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">root@oneplus3:/ # iptables -F</span><br><span class="line">root@oneplus3:/ # iptables -P INPUT ACCEPT</span><br><span class="line">root@oneplus3:/ # iptables -P FORWARD ACCEPT</span><br><span class="line">root@oneplus3:/ # iptables -t nat -A POSTROUTING -o wlan0 -j MASQUERADE</span><br></pre></td></tr></table></figure><p>这样 ip 就能 ping 的通了，但是 DNS 还是不正常，连接热点的设备手动设置 DNS 的话，就可以正常上网了。重启系统的 dnsmasq，让 DHCP 自动分配 DNS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@oneplus3:/ # killall dnsmasq</span><br><span class="line">root@oneplus3:/ # /system/bin/dnsmasq --no-resolv --no-poll --dhcp-authoritative --server=114.114.114.114 --dhcp-option-force=43,ANDROID_METERED --pid-file --dhcp-range=192</span><br><span class="line">.168.49.2,192.168.49.254,1h</span><br></pre></td></tr></table></figure><p>这样就是配置了一个完整的 wifi 中继了。</p><p>再次开启中继只需</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@oneplus3:/data/local/tmp # ./wpa_cli -p /data/misc/wifi/sockets/ -i p2p0 p2p_group_add persistent=0</span><br></pre></td></tr></table></figure><p>然后在配置网络转发，和 iptables、 dhcp。</p><p>默认两个接口是使用同样的 channel，但是也是可以指定频道的,如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@oneplus3:/data/local/tmp # ./wpa_cli -p /data/misc/wifi/sockets/ -i p2p0 p2p_group_add persistent=0 freq=5825</span><br></pre></td></tr></table></figure><p>获取 channel 信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">root@oneplus3:/ # iwlist wlan0 channel</span><br><span class="line">wlan0     26 channels in total; available frequencies :</span><br><span class="line">          Channel 01 : 2.412 GHz</span><br><span class="line">          Channel 02 : 2.417 GHz</span><br><span class="line">          Channel 03 : 2.422 GHz</span><br><span class="line">          Channel 04 : 2.427 GHz</span><br><span class="line">          Channel 05 : 2.432 GHz</span><br><span class="line">          Channel 06 : 2.437 GHz</span><br><span class="line">          Channel 07 : 2.442 GHz</span><br><span class="line">          Channel 08 : 2.447 GHz</span><br><span class="line">          Channel 09 : 2.452 GHz</span><br><span class="line">          Channel 10 : 2.457 GHz</span><br><span class="line">          Channel 11 : 2.462 GHz</span><br><span class="line">          Channel 12 : 2.467 GHz</span><br><span class="line">          Channel 13 : 2.472 GHz</span><br><span class="line">          Channel 36 : 5.18 GHz</span><br><span class="line">          Channel 40 : 5.2 GHz</span><br><span class="line">          Channel 44 : 5.22 GHz</span><br><span class="line">          Channel 48 : 5.24 GHz</span><br><span class="line">          Channel 52 : 5.26 GHz</span><br><span class="line">          Channel 56 : 5.28 GHz</span><br><span class="line">          Channel 60 : 5.3 GHz</span><br><span class="line">          Channel 64 : 5.32 GHz</span><br><span class="line">          Channel 149 : 5.745 GHz</span><br><span class="line">          Channel 153 : 5.765 GHz</span><br><span class="line">          Channel 157 : 5.785 GHz</span><br><span class="line">          Channel 161 : 5.805 GHz</span><br><span class="line">          Channel 165 : 5.825 GHz</span><br><span class="line">          Current Frequency:5.765 GHz (Channel 153)</span><br></pre></td></tr></table></figure><p>可在 <code>/data/misc/dhcp/dnsmasq.leases</code> 文件中查看连接的客户端。</p><h2 id="参考"><a class="header-anchor" href="#参考">¶ </a>参考</h2><ul><li><a href="http://fqrouter.tumblr.com/post/47259845553/%E6%97%A0%E7%BA%BF%E4%B8%AD%E7%BB%A7%E5%90%AF%E5%8A%A8%E7%9A%84%E6%9D%A1%E4%BB%B6" target="_blank" rel="noopener">无线中继启动的条件</a></li><li><a href="http://fqrouter.tumblr.com/post/43575459548/%E4%BD%BF%E7%94%A8%E6%89%8B%E6%9C%BA%E5%81%9A%E6%97%A0%E7%BA%BF%E4%B8%AD%E7%BB%A7%E7%9A%84%E5%8F%AF%E8%83%BD%E6%80%A7%E6%8E%A2%E5%AF%BB" target="_blank" rel="noopener">使用手机做无线中继的可能性探寻</a></li><li><a href="http://fqrouter.tumblr.com/post/44298169558/%E8%81%94%E6%83%B3p770%E6%89%8B%E6%9C%BAmtk6577%E6%97%A0%E7%BA%BF%E4%B8%AD%E7%BB%A7%E8%84%9A%E6%9C%AC%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">联想P770手机（MTK6577）无线中继脚本配置方法</a></li><li><a href="https://github.com/fqrouter/fqrouter/blob/master/manager/wifi.py" target="_blank" rel="noopener">wifi repeater start script</a></li><li><a href="http://lists.shmoo.com/pipermail/hostap/2012-November/026931.html" target="_blank" rel="noopener">PATCH</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Openwrt-x86 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为 EMUI 5.0 root 方法</title>
      <link href="2016/12/21/huawei-EMUI50-rootway/"/>
      <url>2016/12/21/huawei-EMUI50-rootway/</url>
      
        <content type="html"><![CDATA[<p>华为 EMUI 5.0 root 方法和分析</p><h3 id="华为-emui5-0-获取-root-方法"><a class="header-anchor" href="#华为-emui5-0-获取-root-方法">¶ </a>华为 EMUI5.0 获取 root 方法</h3><p>华为EMUI5.0 目前 root 方法是刷TWRP，然后使用 TWRP 刷入 Chainfire 的 SuperSU 或者 phh 的 Superuser。你需要支持 Nougat 版本的 TWRP，但是在刷入 Chainfire 的 SuperSU 过程中会直接导致设备重启，因为 SuperSU 的工作原理是在采用 systemless 时无论在刷入还是开机过程中都需要 mount 一个 loop 设备 su.img，猜测是华为的 kernel 做了限制，当 mount 一个 loop 设备时设备会直接重启最后进入到 erecovery.</p><a id="more"></a><p>使用 phh 的 Superuser 则无此问题，但是默认提供的 Superuser 版本是开启了 dm-verity 和 forceencrypt，因为 dm-verity 的存在导致获取到的 root 权限是不完整的，无法对 system 分区做任何修改，所以自己修改了一个 Superuser-r275 的版本，关闭了这两个开关.</p><p>同时也借鉴 phh 的做法，将 SuperSU 相关 su 文件放到 ramdisk 下并移除 su.img 的创建和挂载过程，最后对 sepolicy 重新打 patch，这部分脚本完全来自 phh 的 Superuser. 但是因此也失去了 SuperSU 特有的一些功能，例如 frp 和 app 内更新二进制的功能，升级版本只能通过重刷来解决.</p><p>至于最终到底是不是华为 kernel的限制，还是需要等华为开源时，才能最终解决.</p><h2 id="frd-al00-root-所需文件"><a class="header-anchor" href="#frd-al00-root-所需文件">¶ </a>FRD-AL00 root 所需文件</h2><p>自己测试的机器是荣耀8 FRD-AL00 版本，需要到的文件：</p><ul><li><a href="https://mega.nz/#!XR91RJrL!zKgVWf8WvBGlP3n0Aip59tT1Z3l8C2Lh6smsijw3wQQ" target="_blank" rel="noopener">frd-twrp</a></li><li><a href="https://mega.nz/#!2Y8CgIDa!RvUXD1dJKYA0xBPHRfzVy0wj_CZXPw-bMdZJLpypHUY" target="_blank" rel="noopener">SuperSU</a></li><li><a href="https://mega.nz/#!PYshWCZZ!SwrpezliztIFKooEY5Np7zT2m7yWmp6QtjlTExntakU" target="_blank" rel="noopener">phh Superuser</a></li></ul><p>该 recovery 应该也同样适用于华为P9,或者其他的 hi3650 机器.</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> root </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成用于 Verifiedboot 的 system.img</title>
      <link href="2016/07/05/buid-verifiedboot-system-image/"/>
      <url>2016/07/05/buid-verifiedboot-system-image/</url>
      
        <content type="html"><![CDATA[<p>Android 从 6.0 开始启用了 Verifiedboot，来保证系统的完整性</p><h2 id="getveritytreesize-和-getveritymetadatasize"><a class="header-anchor" href="#getveritytreesize-和-getveritymetadatasize">¶ </a>GetVerityTreeSize 和 GetVerityMetadataSize</h2><p><code>build_verity_tree -s 2046820352</code></p><p><code>build_verity_metadata.py -s 2046820352</code></p><p>该两个方法在源码的 <code>./tools/releasetools/build_image.py</code> 中.</p><p>参数是真实 system 分区的大小</p><h2 id="生成预留空间的-system-simg"><a class="header-anchor" href="#生成预留空间的-system-simg">¶ </a>生成预留空间的 system.simg</h2><p>要重新打包 system.simg 给 verity_tree 和 verity_metadata 预留出空间，<code>-l</code>指定的大小为真实 system 空间的大小减去上一步分别得到的大小</p><a id="more"></a><h2 id="生成-root-hash-即-verity-tree"><a class="header-anchor" href="#生成-root-hash-即-verity-tree">¶ </a>生成 root_hash 即 verity_tree</h2><p><code>build_verity_tree -A aee087a5be3b982978c923f566a94613496b417f2af592639bc80d141e34dfe7 system.simg verity.img</code></p><p>其中 <code>aee087a5be3b982978c923f566a94613496b417f2af592639bc80d141e34dfe7</code> 是 salt，<code>system.simg</code> 需要是 sparse image，生成 verity.img.</p><p>命令输出例子</p><p><code>3a82cfc74206a6a8b467fb699022d86ea36dee48b04fc8b40585d2cad941f463 aee087a5be3b982978c923f566a94613496b417f2af592639bc80d141e34dfe7</code></p><p>第一个就是后面要用到的 root_hash 值。</p><h2 id="生成-verity-metadata"><a class="header-anchor" href="#生成-verity-metadata">¶ </a>生成 verity_metadata</h2><p><code>build_verity_metadata.py 2030665728 verity_metadata.img 3a82cfc74206a6a8b467fb699022d86ea36dee48b04fc8b40585d2cad941f463 aee087a5be3b982978c923f566a94613496b417f2af592639bc80d141e34dfe7 /dev/block/platform/msm_sdcc.1/by-name/system verity_signer verity.pk8</code></p><p>其中第一个参数是预留了空间后的 system 大小，后面的分别是 root_hash、salt、system 分区在手机里的分区、signer_path、私钥。最后生成 verity_metadata.img，32768 个字节 32kb 是固定值。</p><h2 id="生成最终的-image"><a class="header-anchor" href="#生成最终的-image">¶ </a>生成最终的 image</h2><p><code>append2simg system.simg verity_metadata.img</code></p><p><code>append2simg system.simg verity.img</code></p><p>分别是前两步中生成的文件。</p><h2 id="参考"><a class="header-anchor" href="#参考">¶ </a>参考</h2><ul><li><a href="http://blog.andrsec.com/android/2015/04/10/android-boot-verity.html" target="_blank" rel="noopener">Android secrue boot</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> verifiedboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>采用 LVM 扩展 Home 分区</title>
      <link href="2016/07/05/use-lvm-spread-home-partition/"/>
      <url>2016/07/05/use-lvm-spread-home-partition/</url>
      
        <content type="html"><![CDATA[<p>电脑是双系统，从windows下压缩出了部分空间，来扩展ubuntu的home分区</p><h2 id="创建lvm"><a class="header-anchor" href="#创建lvm">¶ </a>创建lvm</h2><p><code>sudo apt-get install lvm2</code></p><p><code>sudo fdisk /dev/sda</code>,新建分区后，输入<code>t</code>，输入要改变分区类型的分区号，输入<code>8e</code>，最后<code>w</code>保存。</p><p><code>sudo partprobe</code> 重读分区表,此时可能需要重启一下，要不下面一步会提示not found.</p><p><code>sudo pvcreate /dev/sda4</code>  创建物理卷PV，让刚刚的分区可用</p><a id="more"></a><p><code>sudo pvdisplay</code> 查看PV</p><p><code>sudo vgcreate ext_vol /dev/sda4</code> 创建逻辑卷组VG，创建完毕之后，可以在/dev/下面看见设备</p><p><code>sudo vgdisplay</code> 查看VG</p><p><code>sudo lvcreate --name home --size 48G ext_vol</code> 创建逻辑卷分区LV，创建完毕之后，就可以在/dev/ext_vol/下看见分区了，然后这个分区就可以操作了<br>或者<code>sudo lvcreate --name home -l +100%FREE 48G ext_vol</code>,使用全部空间</p><p><code>sudo lvdisplay</code></p><p><code>sudo mkfs.ext4 /dev/ext_vol/home</code> 格式化</p><p>然后就可以挂载使用了</p><h2 id="迁移home分区"><a class="header-anchor" href="#迁移home分区">¶ </a>迁移home分区</h2><p>进入rescue mode模式，把原先的home分区挂载到/home目录下，把<code>/dev/ext_vol/home</code>挂载到/home1目录下，操作前要让分区可写<code>mount -o remount rw /</code>,然后<code>cp -afR /home/* /home1</code>,最后修改<code>/etc/fstab</code>自动挂载。</p><h2 id="将原先的home分区也添加到lvm中"><a class="header-anchor" href="#将原先的home分区也添加到lvm中">¶ </a>将原先的home分区也添加到lvm中</h2><ul><li>修改分区类型为8e</li><li>重载分区表</li><li>格式化</li><li>创建PV</li><li><code>sudo vgextend ext_vol /dev/sda8</code> #扩展逻辑卷组ext_vol</li><li><code>sudo lvextend -l +100%FREE /dev/ext_vol/home</code> 扩容LV的home分区，使用全部的VG空间</li><li>再次进入rescue mod模式下，<code>resize2fs /dev/ext_vol/home</code></li></ul><h2 id="参考"><a class="header-anchor" href="#参考">¶ </a>参考</h2><ul><li><a href="http://www.cnblogs.com/gaojun/archive/2012/08/22/2650229.html" target="_blank" rel="noopener">Linux LVM硬盘管理及LVM扩容</a></li><li><a href="http://www.cnblogs.com/yasmi/articles/4835644.html" target="_blank" rel="noopener">Ubuntu Server上的LVM配置</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于高通 9008 刷机的研究</title>
      <link href="2015/09/01/about-qcom-edl-dload-study/"/>
      <url>2015/09/01/about-qcom-edl-dload-study/</url>
      
        <content type="html"><![CDATA[<h2 id="生成所需xml"><a class="header-anchor" href="#生成所需xml">¶ </a>生成所需xml</h2><h3 id="gpt-分区-parse-gpt"><a class="header-anchor" href="#gpt-分区-parse-gpt">¶ </a>GPT 分区 parse_gpt</h3><p>根据官方 GPT 文件解析出具体的 GPT 的分区信息并生成对应平台的 partiiton.xml 文件，最后通过 <a href="http://ptool.py" target="_blank" rel="noopener">ptool.py</a> 生成可刷写的配置文件 rawprogram0.xml、patch0.xml 跟最后的 GPT。</p><p>官方的 gpt 文件一般需要经过裁剪,一般裁剪成 17408 字节大小，包括文件头开始的 512 字节的 MBR 信息 <code>dd if=gpt.bin of=gpt-new.bin bs=17408 count=1</code>,然后使用 <code>./parse_gpt gpt-new.bin</code>，输出在 <code>GPT_DUNP_FILES</code> 中。</p><p>或者在手机中 <code>dd if=/dev/block/mmcblk0 of=/sdcard/gpt-new.bin bs=17408 count=1</code>，为配合 parse_gpt,大小一般为 17408/34304。</p><a id="more"></a><h3 id="mbr-分区"><a class="header-anchor" href="#mbr-分区">¶ </a>MBR 分区</h3><p>上面所说的是 GPT 分区的，但是一些老平台的机器依然使用的是 MBR 分区，例如 msm7x30 和 msm8x60 平台</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">partition.xml           - Everything begins with this file, which describes the number of </span><br><span class="line">                          partitions desired, and how many sectors each one should be.</span><br><span class="line">PartitioningTool.py     - translates partition.xml into binary partitions</span><br><span class="line">msp.exe                 - writes binary partitions to SD/eMMC cards using card reader</span><br><span class="line">mjsdload.cmm            - writes binary partitions to SD/eMMC cards using Trace32</span><br><span class="line">msp.py                  - writes binary partitions to a single image file</span><br><span class="line">QPST                    - writes binary partitions to SD/eMMC cards on Target</span><br><span class="line">parseBinaryPartitionFile.pl     - Decodes MBR partition tables. Run: </span><br><span class="line">                                  &quot;Perl parseBinaryPartitionFile.pl partition.bin&quot; </span><br><span class="line">                                  to generate the partition information</span><br><span class="line">parseGPT.pl                     - Decodes GPT partition tables</span><br></pre></td></tr></table></figure><ul><li><a href="http://forum.xda-developers.com/showthread.php?p=31843325" target="_blank" rel="noopener">eMMC Partition tools usage for msm7x30/msm8x60</a></li></ul><h3 id="ptool-py"><a class="header-anchor" href="#ptool-py">¶ </a><a href="http://ptool.py" target="_blank" rel="noopener">ptool.py</a></h3><p><code>python ptool.py –x partition.xml</code></p><p>这些工具源于高通的 modem 源码，当然是闭源的了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">boot_images/core/storage/tools/ptool/</span><br><span class="line">ptool.py         //分区生成工具 partition =========&gt; rawprogram0.xml</span><br><span class="line">                    Python ptool.py –x partition.xml:</span><br><span class="line">msp.py          //ubuntu使用：根据 rawprogram0.xml进行升级软件工具</span><br><span class="line">singleimage.py　　//根据singleimage_partition_8974.xml生成single boot image: 8974_msimage.mbn, python singleimage.py -x singleimage_partition_8974.xml</span><br><span class="line">lsusb.py       // ls usb</span><br><span class="line">dd.py            // dd command</span><br><span class="line">checksparse.py         //sparse system/cache/userdata image</span><br><span class="line"></span><br><span class="line">[checksparse.py的使用](http://kernel-develop.blogspot.com/2012/06/emmc-sparse-image-download-in-msm8x60.html)</span><br></pre></td></tr></table></figure><p>一个整合的工具，包括刷机命令行刷机的 <code>qdload.pl</code></p><ul><li><a href="https://github.com/M1cha/aries-image-builder" target="_blank" rel="noopener">aries-image-builder</a></li></ul><h3 id="文件说明"><a class="header-anchor" href="#文件说明">¶ </a>文件说明</h3><ol><li>8x10_msimage.mbn ----平台镜像，是个完整的最小系统启动镜像，包括 sbl，tz，sdi，rpm 等必要启动分区和分区表</li><li>MPRG8x10.hex ----对应平台的串口烧写协议</li><li>gpt_both0.bin ----对应 EMMC 的分区表，因为不同批次的 EMMC 大小有细微差别，这个分区表不包含最后一个分区信息</li><li>rawprogram0.xml ----要烧写的具体文件跟对应的扇区位置</li><li>patch0.xml ----刷机软件根据手机服务端返回的具体磁盘大小打上最后一个分区的补丁、完成分区表头校验的配置文件，没有正确的 patch0.xml 分区表头就不能通过校验，手机也启动不了</li></ol><p>8x10_msimage.mbn、MPRG8x10.hex 是通用的并可以在网上直接获取，单让手机进入磁盘模式，只需要 msimage 和 MPRG 即可。</p><h3 id="msimage-生成"><a class="header-anchor" href="#msimage-生成">¶ </a>msimage 生成</h3><p>生成自己的 msimage.mbn，在 msm7k 平台需要 MBR0.bin 和 <code>qcsblhd_cfgdata.mbn/qcsbl.mbn/oemsblhd.mbn/oemsbl.mbn</code> 或者完整的 <code>dbl/osbl</code>。</p><p>在 msm8k 平台后需要 gpt，<code>sbl1/sbl2/sbl3/rpm/tz</code>。并不建议自己生成 msimage，防止成真砖。</p><h4 id="win-未验证"><a class="header-anchor" href="#win-未验证">¶ </a>Win(未验证）</h4><p><a href="http://kernel-develop.blogspot.com/2012/05/how-to-generate-8660msimagembn.html" target="_blank" rel="noopener">How to generate the 8660_msimage.mbn</a><br><a href="http://kernel-develop.blogspot.com/2012/04/how-to-build-emmc-flash-programmer.html" target="_blank" rel="noopener"> How to build eMMC flash programmer MPRG7x30.hex and 7x30_msimage.mbn</a></p><p><code>emmcswdownload.exe -f 8660_msimage.mbn -x partition_boot.xml -s 16G</code></p><p>注意现在新版的 QPST，也只支持由 rawprogram0.xml 来生成 msimage 了。</p><h4 id="linux"><a class="header-anchor" href="#linux">¶ </a>Linux</h4><p><a href="http://kernel-develop.blogspot.com/2012/05/how-to-generate-7x30msimagembn.html" target="_blank" rel="noopener">How to generate the 7x30_msimage.mbn </a></p><p><code>python msp.py -r rawprogram0.xml -d 2048</code><br>生成 2048Kb，rawprogram0.xml 和其它一些文件如分区 mbr gpt 等是由上面所提到的 <a href="http://ptool.py" target="_blank" rel="noopener">ptool.py</a> 生成.这个 rawprogram0.xml 只需要包含生成 msimage 的必须项即可，可以手动直接修改，也可以修改 partition.xml，添加更多的启动分区命名成上面提到的 partition_boot.xml，然后再生成 rawprogram0.xml。</p><p>添加更多的分区，只要有该分区的镜像或者备份即可，比如包含 bootloader，这样有可能就可以直接启动到 bootloader 模式下刷机了，或者 NON-HLOS 等，或者一个完整的 rawprogram0.xml，这就相当于直接刷机了，但是这样生成的 msimage 将会非常大，刷起来非常的慢。</p><h2 id="edl-模式"><a class="header-anchor" href="#edl-模式">¶ </a>edl 模式</h2><p>就是常说的救砖模式，一般高通手机只要没有硬件问题,使用 QHSUSB DLOAD 模式一般都救的回来，使用的是高通的 sahara和 firehose 协议，是 msm8k 以后平台的协议标准，两种协议分别使用 eMMC Software Download 和 QFIL(Qualcomm Flash Image Loader) 刷机，这两个工具全部包括在高通的QPST中。在这两种协议下，在 9008 模式时烧写进去的大概只有五个文件，然后系统会进入 9006 模式，这个模式下系统会识别 qualcomm emmc 磁盘,此时就可以恢复各分区的备份，或者直接写入关键的系统分区备份(可以使用UltraISO/HDD Raw Copy Tools等工具)，这样就可以进入 recovery/bootloader 进行刷机，也可以使用 QFIL 或 Miflash 或 Msm8974 Download Tool等救砖工具一步完成。</p><p>在 msm7k 平台以前是没有 EDL 急救模式的，出了问题只能 JTAG。</p><p>备份的时候可以使用 dd 命令备份出整个磁盘，或者系统关键分区。或者使用<a href="http://4pda.ru/forum/index.php?showtopic=655617" target="_blank" rel="noopener">emmc raw tool</a></p><p>msimage MPRG 是 Sahara 协议下刷机的必需的，而 firehose 协议下的必须文件变成了 <code>prog_emmc_firehose_platform.mbn</code>，看文件就可以知道使用的是什么协议。而以前的例如 msm7k 平台有的使用的是 stream dload 协议，QPST 工具里面使用的是 Software Download，和 Sahara 协议相比，并不需要 msimage，也不需要 xml，只需要串口烧写协议如 <code>eNPRG hex</code> 和 <code>dbl/osbl</code>，实际上 Sahara 协议所使用的 msimage 刚好是 <code>dbl/osbl</code> 的结合体，so，<code>prog_emmc_firehose_platform.mbn</code>也是 msimage 和 MPRG hex 的结合体？</p><p>stream dload 协议救砖方法:</p><p><a href="http://kernel-develop.blogspot.com/2012/05/how-to-program-emmc-images-into-blank.html" target="_blank" rel="noopener">How to program eMMC images into blank flash with USB only in MSM7630 </a><br><a href="http://blog.csdn.net/fybon/article/details/18263191" target="_blank" rel="noopener"> qualcomm 8K平台Sahara Protocol相对7K, 6K 平台Software Download优点 </a></p><p>总结就是：8k Sahara Protocol省去了 CRC，打包、解包的过程直接传输 raw data，效率高。<br>同样的使用此模式刷机可以绕过华为的 MD5withRSA 的签名校验。</p><ul><li>一般手机都有特别的按键方式进入,例如 <code>vol+ &amp; usb</code> 等等</li><li>使用 <code>adb reboot edl</code> 或者 <code>adb reboot dload</code> 或者 <code>fastboot oem reboot-edl</code></li><li>清除tz分区 <code>cat /dev/zero &gt; /dev/block/platform/msm_sdcc.1/by-name/tz</code> 或者其它重要的分区如 sbl 分区、aboot 分区，也可在 fastboot 下直接 erase</li><li>当只能被识别为 9006 模式时，如果想切换到 9008，可以使用磁盘管理工具重建分区表，或者删除关键分区</li><li>拆机，短接测试点：把电信卡槽上面的金属片跟测试点连在一起，测试点要拆机才能看到（彻底黑砖的用这个方法）</li></ul><h2 id="qfil-command-line"><a class="header-anchor" href="#qfil-command-line">¶ </a>QFIL Command Line</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">qfil.exe -Mode=1 -COM="enter your comport number setting here" -SEARCHPATH="enter your complete path to 8675_W00 folder" -Sahara=true;"enter your complete path to the prog_emmc_FireHose_8936.mbn" -RawProgram=rawprogram0.xml -patch=patch0.xml -AckRawDataEveryNumPackets=TRUE;100 -DeviceTYPE="eMMC" -PlatForm="8x26" -MaxPayloadSizeToTargetInBytes="49152"</span><br><span class="line"></span><br><span class="line">Here are example to use it</span><br><span class="line"></span><br><span class="line">qfil.exe -Mode=1 -COM=64 -SEARCHPATH="D:\CBW8600A01_A_T1701" -Sahara=true;"D:\CBW8600A01_A_T1701\prog_emmc_FireHose_8x26.mbn" -RawProgram=rawprogram_unsparse.xml,rawprogram2.xml -patch=patch0,patch2.xml -AckRawDataEveryNumPackets=TRUE;100 -DeviceTYPE="eMMC" -PlatForm="8x26" -MaxPayloadSizeToTargetInBytes="49152"</span><br></pre></td></tr></table></figure><p><img src="http://forum.xda-developers.com/attachment.php?attachmentid=3261470&amp;stc=1&amp;d=1428998570" alt="参数参考"><br>更多文档在 QPST 软件的目录中。</p><h2 id="华为免解锁"><a class="header-anchor" href="#华为免解锁">¶ </a>华为免解锁</h2><p>官方卡刷跟官方平台线刷都会校验每个字节，每个文件，每个镜像文件都是 CRC32k 算法校验的，这是公开的。还有就是华为为防止文件的数据被修改还加了 MD5withRSA 加密算法，这个需要华为的私钥文件才能校验成功，私钥只有华为知道。</p><h3 id="解锁方法"><a class="header-anchor" href="#解锁方法">¶ </a>解锁方法</h3><ul><li>官方申请解锁码</li><li>将其它手机解完锁后的 oeminfo.img 写入 oeminfo 分区,进行强制解锁,但是IMEI之类的貌似就是别人的了</li><li>使用 edl 模式,刷入修改后的 oeminfo 分区镜像,或者直接修改 <code>echo -ne '\x02' | dd of=/dev/block/mmcblk0p3 bs=1 seek=33669144 conv=notrunc</code></li><li><a href="http://forum.xda-developers.com/showthread.php?t=2541843" target="_blank" rel="noopener">TUTORIAL: Remove <em>TAMPERED</em> &amp; <em>RELOCKED</em> flag </a></li><li><a href="http://www.in189.com/thread-1079000-1-1.html" target="_blank" rel="noopener">沃日，华为的解锁原理竟是如此的简单</a></li><li>十六个U是什么鬼,配合特定的机型,特定的 ROM 版本(efi fastboot),可实现解锁?</li></ul><p>华为的手机存在解锁后没法降级的情况,就算重新锁上也是不行的.可以 <code>dd if=/dev/urandom of=/dev/block/mmcblk0p8 bs=512 count=10</code> 向 oeminfo 分区写入随机数据(记得备份),重启后 bootloader 就会重新锁上，就可以自由升降级了。</p><h2 id="参考"><a class="header-anchor" href="#参考">¶ </a>参考</h2><ul><li><a href="http://blog.csdn.net/fybon/article/details/37565227" target="_blank" rel="noopener">高通 MSM8K bootloader</a></li><li><a href="http://www.in189.com/thread-1107257-1-1.html" target="_blank" rel="noopener">[教程] 高通平台线刷ROM制作简明教程，暴力ROOT</a></li><li><a href="http://blog.csdn.net/su_ky/article/details/7773273" target="_blank" rel="noopener">IM-A820L显示QHSUSB_DLOAD的救砖方案</a></li><li><a href="http://blog.csdn.net/ziyouwa/article/details/8620595" target="_blank" rel="noopener">A840S黑砖修复过程</a></li><li><a href="http://blog.csdn.net/benjaminwan/article/details/8854437" target="_blank" rel="noopener">泛泰SKYA850救砖原理与分区表解析</a></li><li><a href="http://blog.csdn.net/benjaminwan/article/details/8804647" target="_blank" rel="noopener">泛泰SKYA850黑砖QHSUSB_DLOAD救砖教程</a></li><li><a href="http://forum.xda-developers.com/showthread.php?t=2136738" target="_blank" rel="noopener">SHV-E160L Debricking Tool / Qualcomm Tool Pack V2-1</a></li><li><a href="http://forum.xda-developers.com/showthread.php?t=1978703" target="_blank" rel="noopener">[REF][R&amp;D] Building Bootloaders on Qualcomm Devices</a></li><li><a href="http://forum.xda-developers.com/showthread.php?t=2086142" target="_blank" rel="noopener">[R&amp;D][QUALCOMM] Using QDL, EHostDL and DIAG interfaces &amp; features</a></li><li><a href="http://forum.xda-developers.com/yureka/help/question-qualcomm-download-mode-k-t3068040" target="_blank" rel="noopener">[PROJECT] Reviving Hard Bricked YU (QLoader 9008 Mode)</a></li><li><a href="http://forum.xda-developers.com/mi-2/orig-development/flashtools-miflash4linux-recovery-qdl-t3036730" target="_blank" rel="noopener">Flashtools (MiFlash4Linux, Recovery from QDL/DLOAD, Partition resize)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EDL </tag>
            
            <tag> DLOAD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2015夏稻城亚丁</title>
      <link href="2015/07/11/yading/"/>
      <url>2015/07/11/yading/</url>
      
        <content type="html"><![CDATA[<p><img src="http://i.imgur.com/jtmdfPZ.jpg" alt="仙乃日神山"></p><blockquote><p>稻城亚丁仙乃日神山，摄于2015年夏318之行</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 相册 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenWrt-x86 笔记</title>
      <link href="2015/03/09/openwrt-x86-note/"/>
      <url>2015/03/09/openwrt-x86-note/</url>
      
        <content type="html"><![CDATA[<p>此乃 OpenWrt-x86 编译时的笔记，很乱、不够系统，但以后完善</p><h2 id="目标硬件"><a class="header-anchor" href="#目标硬件">¶ </a>目标硬件</h2><ul><li>Intel NUC D34010WYK</li><li>4g 内存</li><li>60g SSD</li><li>Intel N2230无线网卡</li></ul><h2 id="x86-编译注意事项"><a class="header-anchor" href="#x86-编译注意事项">¶ </a>x86 编译注意事项</h2><ul><li>大内存支持</li><li>多核心，多线程支持</li><li>sata drive 支持</li><li>网卡、wifi 驱动的集成</li><li>对 usb，例如鼠标、键盘的支持</li><li>编译所有文件系统支持，包括 ext2/ext3/ext4，还有 NTFS，甚至是 LVM；</li><li>加入一个文本编辑器，例如 vim 或者 nano，因为日常使用中需要用文本编辑器修改各种配置文件；</li><li>加入所有关于无线网卡的驱动，模块，各种支持程序，</li><li>一些其他常见应用–蓝牙、加密、PGP、SSL、SSH、VPN、USB支持、3G上网卡</li></ul><a id="more"></a><h2 id="convert-openwrt-raw-image"><a class="header-anchor" href="#convert-openwrt-raw-image">¶ </a>Convert OpenWrt raw image</h2><ol><li><code>gunzip openwrt.img.gz</code></li><li><code>VBoxManage convertfromraw --format VDI openwrt.img openwrt.vdi</code></li></ol><h2 id="compile"><a class="header-anchor" href="#compile">¶ </a>Compile</h2><pre><code>make menuconfigmake kernel_menuconfig</code></pre><h2 id="真机使用注意事项"><a class="header-anchor" href="#真机使用注意事项">¶ </a>真机使用注意事项</h2><ul><li>在 bios 中对 ide、sata 的修改</li></ul><h2 id="编译流程"><a class="header-anchor" href="#编译流程">¶ </a>编译流程</h2><h3 id="流程"><a class="header-anchor" href="#流程">¶ </a>流程</h3><ol><li><code>./scripts/feeds update -a</code></li><li><code>./scripts/feeds install -a</code></li><li>检查编译环境，若可进行编译则生成默认配置 <code>make defconfig</code></li><li><code>make menuconfig</code> 若有需求，则可以 <code>make kernel_menuconfig</code></li><li><code>make -j32 V=99</code>，编译过程中会联网下载一些 package</li></ol><p>编译完成的文件，在 bin/x86 目录下，可以烧写到U盘中测试。</p><ul><li><a href="http://wiki.openwrt.org/doc/howto/build" target="_blank" rel="noopener">how to build</a></li></ul><h3 id="单独编译某个包"><a class="header-anchor" href="#单独编译某个包">¶ </a>单独编译某个包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make packages/xxx/clean</span><br><span class="line">make packages/xxx/compile</span><br><span class="line">make packages/xxx/install</span><br></pre></td></tr></table></figure><h2 id="未完成的工作"><a class="header-anchor" href="#未完成的工作">¶ </a>未完成的工作</h2><ul><li><p>配置 wifi 热点的自动开启</p></li><li><p>音频、视频的支持</p></li><li><p>电源键的支持</p></li><li><p>U盘的自动挂载</p></li><li><p>3g/4g 上网卡的支持</p></li><li><p>对 sata 的支持</p></li><li><p><a href="http://lotors.me/2014/08/16/opcompilepro/" target="_blank" rel="noopener">编译过程和后期的一些配置参考</a></p></li></ul><h2 id="gargoyle-的编译"><a class="header-anchor" href="#gargoyle-的编译">¶ </a>Gargoyle 的编译</h2><h3 id="如果有目标硬件"><a class="header-anchor" href="#如果有目标硬件">¶ </a>如果有目标硬件</h3><p><code>make FULL_BUILD=ture brcm47xx</code><br><code>make brcm47xx</code> 是rebuild</p><h3 id="自由定制"><a class="header-anchor" href="#自由定制">¶ </a>自由定制</h3><p><code>make custom</code>，上述命令会自动调用 <code>make menuconfig</code>配置菜单，但是第二次执行时就会跳过配置界面，所以要<code>make FULL_BUILD=true custom</code></p><h2 id="首次配置的方法"><a class="header-anchor" href="#首次配置的方法">¶ </a>首次配置的方法</h2><p>设备成功启动后，连接到该 AP 上，telnet 到 <code>192.168.1.1</code>,输入 <code>passwd</code>，设置密码后，才能使用 ssh 登陆，然后配置网络即可。如果设备启动失败，只有连接显示器查看原因了。</p><hr><h2 id="一些软件的安装"><a class="header-anchor" href="#一些软件的安装">¶ </a>一些软件的安装</h2><h3 id="安装-luci"><a class="header-anchor" href="#安装-luci">¶ </a>安装 luci</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">opkg update</span><br><span class="line">opkg intsall luci</span><br><span class="line">安装完毕记得启动luci</span><br><span class="line">./etc/init.d/uhttpd enable</span><br><span class="line">./etc/init.d/uhttpd start</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">opkg install kmod-usb-core</span><br><span class="line">opkg install kmod-usb-ohci          #安装usb ohci控制器驱动</span><br><span class="line">opkg install kmod-usb-uhci     　#UHCI　USB控制器</span><br><span class="line">opkg install kmod-usb2                #安装usb2.0</span><br><span class="line">opkg install kmod-usb-storage     #安装usb存储设备驱动</span><br><span class="line">opkg install kmod-fs-ext3              #安装ext3分区格式支持组件</span><br><span class="line">opkg install mount-utils                #挂载卸载工具</span><br><span class="line">opkg install ntfs-3g                      #挂载NTFS</span><br><span class="line">opkg install kmod-fs-vfat              #挂载FAT</span><br><span class="line">opkg install block-mount</span><br><span class="line">opkg install fdisk    </span><br><span class="line">opkg install usbutils #安装了这个后可以用 lsusb</span><br><span class="line">opkg install pciutils</span><br></pre></td></tr></table></figure><h2 id="具体配置"><a class="header-anchor" href="#具体配置">¶ </a>具体配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Target System (x86)    #目标平台选择,这里选择X86，如果非x86系统下面需要选择</span><br><span class="line">TargetImages  ---&gt;</span><br><span class="line">ext4    #生成.EXT4.IMG文件</span><br><span class="line">[0] seconds to wait befor booting the default entry  #启动不等待5秒</span><br><span class="line">Base system  ---&gt;</span><br><span class="line">&lt;*&gt; block-mount  #以后挂载USB用</span><br><span class="line">kernel modules  ---&gt;</span><br><span class="line">    Block Devices ---&gt;       这项用于支持磁盘</span><br><span class="line">        &lt;*&gt; kmod-ata-core    #支持SATA硬盘</span><br><span class="line">        &lt;*&gt;   kmod-ata-ahci  </span><br><span class="line">        &lt;*&gt; kmod-loop</span><br><span class="line">    Filesystems  ---&gt;</span><br><span class="line">        &lt;*&gt; kmod-fs-ext4   </span><br><span class="line">    NativeLanguage Support  ---&gt;   #语言支持</span><br><span class="line">        &lt;*&gt; kmod-nls-iso8859-1</span><br><span class="line">        &lt;*&gt; kmod-nls-utf8</span><br><span class="line">    Network Devices  ---&gt;   #网卡驱动，必须添加自己需要的网卡驱动</span><br><span class="line">        &lt;*&gt; kmod-macvlan  </span><br><span class="line">    Wireless Drivers  ---&gt; #wifi卡驱动，添加自己需要的</span><br><span class="line">Luci-----</span><br><span class="line">Collection----luci</span><br><span class="line">Translation---luci-i18n-chinese</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input modules  ---&gt;#键盘</span><br><span class="line">         -*- kmod-hid</span><br><span class="line">         &lt;*&gt; kmod-hid-generic</span><br><span class="line">         -*- kmod-input-core</span><br><span class="line">         -*- kmod-input-evdev</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Kernel modules:</span><br><span class="line">    USB Support:</span><br><span class="line">        &lt;*&gt; Kmod-usb-storage</span><br><span class="line">    Filesystems:</span><br><span class="line">        &lt;*&gt; Kmod-fs-ext3</span><br><span class="line">Base system:</span><br><span class="line">    &lt;*&gt; Block-extroot</span><br><span class="line">Utilities:</span><br><span class="line">    Filesystem:</span><br><span class="line">        &lt;*&gt; E2fsprogs</span><br><span class="line">    Disc:</span><br><span class="line">        &lt;*&gt; Fdisk &gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Processor type and features  ---&gt;</span><br><span class="line">    [*] Symmetric multi-processing support</span><br><span class="line">    Processor family (Core 2/newer Xeon)  ---&gt;#自行选择处理器平台</span><br><span class="line">    [*] Supported processor vendors  ---&gt;#自行选择处理器平台</span><br><span class="line">    (2) Maximum number of CPUs #自行编辑</span><br><span class="line">    [*] SMT (Hyperthreading) scheduler support#超线程支持</span><br><span class="line">    [*] Multi-core scheduler support </span><br><span class="line">    High Memory Support (4GB)  ---&gt;</span><br></pre></td></tr></table></figure><p>若使用U盘测试，还需配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Target Images  ---&gt; </span><br><span class="line">    (/dev/sda2) Root partition on target device (NEW) #修改 /dev/sda2 为 /dev/sdb2</span><br></pre></td></tr></table></figure><hr><h2 id="对-freeswitch-的集成"><a class="header-anchor" href="#对-freeswitch-的集成">¶ </a>对 freeswitch 的集成</h2><p>目前的两种方法</p><ol><li>直接把 freeswitch 的源码目录放到 openwrt 的 package 目录中，</li><li>做为一个单独的 git 项目，使用该 package 时修改 <code>feeds.conf</code> 添加订阅，然后在 <code>make menuconfig</code> 时选择 freeswitch 模块。</li></ol><p>无论这两种方法，都需要在 freeswith 中增加</p><ul><li>package/Makefile [必备]</li><li>package/patches/ [可选]</li><li>package/files/ [可选]</li></ul><p>patches 目录和files 目录都是可选的，patches 目录通常包括 bug 修复和对可执行文件体积的优化，files 目录通常包括配置文件。</p><h3 id="makefile文件"><a class="header-anchor" href="#makefile文件">¶ </a>Makefile文件</h3><ul><li>PKG_NAME -软件包的名字, 在 menuconfig 和 ipkg 显示</li><li>PKG_VERSION -软件包的版本，主干分支的版本正是我们要下载的</li><li>PKG_RELEASE -这个 makefile 的版本</li><li>PKG_BUILD_DIR -编译软件包的目录</li><li>PKG_SOURCE -要下载的软件包的名字，一般是由 PKG_NAME 和 PKG_VERSION 组成</li><li>PKG_SOURCE_URL -下载这个软件包的链接</li><li>PKG_MD5SUM -软件包的 MD5 值</li><li>PKG_CAT -解压软件包的方法 (zcat, bzcat, unzip)</li><li>PKG_BUILD_DEPENDS -需要预先构建的软件包，但只是在构建本软件包时，而不是运行的的语法和下面的 DEPENDS 一样。</li></ul><h3 id="参考"><a class="header-anchor" href="#参考">¶ </a>参考</h3><ul><li><a href="http://wiki.openwrt.org/zh-cn/doc/devel/packages" target="_blank" rel="noopener">创建软件包</a></li><li><a href="http://wiki.freeswitch.org/wiki/OpenWrt" target="_blank" rel="noopener">configure FreeSWITCH to run on their OpenWrt</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Openwrt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Openwrt-x86 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 12.04 安装搜狗拼音输入法</title>
      <link href="2014/05/19/ubuntu12.04-install-sogoupinyin/"/>
      <url>2014/05/19/ubuntu12.04-install-sogoupinyin/</url>
      
        <content type="html"><![CDATA[<p>新出的linux下的搜狗输入法，颇感兴趣，这里作为记录。</p><h3 id="安装fcitx"><a class="header-anchor" href="#安装fcitx">¶ </a>安装fcitx</h3><p>ubuntu12.04默认源中的fcitx版本较旧，安装新版本的fcitx。</p><pre><code>sudo add-apt-repository ppa:fcitx-team/nightlysudo apt-get update </code></pre><p>如果已经安装了旧版本的fctix，更新:</p><pre><code>sudo apt-get upgrade </code></pre><a id="more"></a><p>更新后，需重启或注销重新登陆。</p><p>未安装，直接安装：</p><pre><code>sudo apt-get install fcitx</code></pre><p>安装googlepinyin和sunpinyin（个人习惯，作为备用）：</p><pre><code>sudo apt-get install fcitx-googlepinyinsudo apt-get install fcitx-sunpinyin</code></pre><p>切换输入法框架为fcitx：</p><pre><code>im-switch -s fcitx </code></pre><h3 id="卸载ibus"><a class="header-anchor" href="#卸载ibus">¶ </a>卸载ibus</h3><p>ibus和fcitx共存时老有一些莫名其妙的bug，所以卸载ibus。</p><pre><code>killall ibus-daemonsudo apt-get autoremove ibus ibus-sunpinyin</code></pre><p>如果你使用的桌面是gnome，请暂时先不要卸载ibus-gtk3，据说会导致进步了系统。</p><p>如果上一步没有重启过，重启或者注销重新登陆。</p><h3 id="安装搜狗拼音"><a class="header-anchor" href="#安装搜狗拼音">¶ </a>安装搜狗拼音</h3><ul><li><a href="http://pinyin.sogou.com/linux/?r=pinyin" target="_blank" rel="noopener">下载安装</a></li></ul><h3 id="遇到的问题"><a class="header-anchor" href="#遇到的问题">¶ </a>遇到的问题</h3><p>小企鹅右键设置启用搜狗pinyin，输入的时候提示：</p><blockquote><p>請啓用fcitx-qimpanel面板程序，以便更好的享受搜狗輸入法！</p></blockquote><p>解决办法：<br>重启 fcitx 切换到 qimpanel，同时开启 qimpanel</p><pre><code>fcitx -r --enable fcitx-qimpanelfcitx-qimpanel </code></pre><p>有时重启系统后，输入法没有输入框的现象，只能盲打，我的解决办法是kill掉fcitx-qimpanel，然后重新启动，不可以的话就多kill掉几次<code>ps -ef | grep qim</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 输入法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sublime_text 支持中文输入</title>
      <link href="2014/05/19/sublime-support-chinese-im/"/>
      <url>2014/05/19/sublime-support-chinese-im/</url>
      
        <content type="html"><![CDATA[<p>让sublime_text支持中文输入，这在ubuntu上是一直不可以的，以前用过插件来达到中文你输入的目的，不过太繁琐。</p><h3 id="安装编译所需依赖"><a class="header-anchor" href="#安装编译所需依赖">¶ </a>安装编译所需依赖</h3><p><code>sudo apt-get install build-essential libgtk2.0-dev</code></p><a id="more"></a><h3 id="源代码"><a class="header-anchor" href="#源代码">¶ </a>源代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sublime-imfix.c</span></span><br><span class="line"><span class="comment">Use LD_PRELOAD to interpose some function to fix sublime input method support for linux.</span></span><br><span class="line"><span class="comment">By Cjacker Huang &lt;jianzhong.huang at i-soft.com.cn&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">gcc -shared -o libsublime-imfix.so sublime_imfix.c  `pkg-config --libs --cflags gtk+-2.0` -fPIC</span></span><br><span class="line"><span class="comment">LD_PRELOAD=./libsublime-imfix.so sublime_text</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtk/gtk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gdk/gdkx.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> GdkSegment GdkRegionBox;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">GdkRegion</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">long</span> size;</span><br><span class="line">  <span class="keyword">long</span> numRects;</span><br><span class="line">  GdkRegionBox *rects;</span><br><span class="line">  GdkRegionBox extents;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GtkIMContext *local_context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">gdk_region_get_clipbox (<span class="keyword">const</span> GdkRegion *region,</span><br><span class="line">            GdkRectangle    *rectangle)</span><br><span class="line">&#123;</span><br><span class="line">  g_return_if_fail (region != <span class="literal">NULL</span>);</span><br><span class="line">  g_return_if_fail (rectangle != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  rectangle-&gt;x = region-&gt;extents.x1;</span><br><span class="line">  rectangle-&gt;y = region-&gt;extents.y1;</span><br><span class="line">  rectangle-&gt;width = region-&gt;extents.x2 - region-&gt;extents.x1;</span><br><span class="line">  rectangle-&gt;height = region-&gt;extents.y2 - region-&gt;extents.y1;</span><br><span class="line">  GdkRectangle rect;</span><br><span class="line">  rect.x = rectangle-&gt;x;</span><br><span class="line">  rect.y = rectangle-&gt;y;</span><br><span class="line">  rect.width = <span class="number">0</span>;</span><br><span class="line">  rect.height = rectangle-&gt;height;</span><br><span class="line">  <span class="comment">//The caret width is 2;</span></span><br><span class="line">  <span class="comment">//Maybe sometimes we will make a mistake, but for most of the time, it should be the caret.</span></span><br><span class="line">  <span class="keyword">if</span>(rectangle-&gt;width == <span class="number">2</span> &amp;&amp; GTK_IS_IM_CONTEXT(local_context)) &#123;</span><br><span class="line">        gtk_im_context_set_cursor_location(local_context, rectangle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this is needed, for example, if you input something in file dialog and return back the edit area</span></span><br><span class="line"><span class="comment">//context will lost, so here we set it again.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> GdkFilterReturn <span class="title">event_filter</span> <span class="params">(GdkXEvent *xevent, GdkEvent *event, gpointer im_context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    XEvent *xev = (XEvent *)xevent;</span><br><span class="line">    <span class="keyword">if</span>(xev-&gt;type == KeyRelease &amp;&amp; GTK_IS_IM_CONTEXT(im_context)) &#123;</span><br><span class="line">       GdkWindow * win = g_object_get_data(G_OBJECT(im_context),<span class="string">"window"</span>);</span><br><span class="line">       <span class="keyword">if</span>(GDK_IS_WINDOW(win))</span><br><span class="line">         gtk_im_context_set_client_window(im_context, win);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> GDK_FILTER_CONTINUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gtk_im_context_set_client_window</span> <span class="params">(GtkIMContext *context,</span></span></span><br><span class="line"><span class="function"><span class="params">          GdkWindow    *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GtkIMContextClass *klass;</span><br><span class="line">  g_return_if_fail (GTK_IS_IM_CONTEXT (context));</span><br><span class="line">  klass = GTK_IM_CONTEXT_GET_CLASS (context);</span><br><span class="line">  <span class="keyword">if</span> (klass-&gt;set_client_window)bbbbbbbb</span><br><span class="line">    klass-&gt;set_client_window (context, window);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!GDK_IS_WINDOW (window))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  g_object_set_data(G_OBJECT(context),<span class="string">"window"</span>,window);</span><br><span class="line">  <span class="keyword">int</span> width = gdk_window_get_width(window);</span><br><span class="line">  <span class="keyword">int</span> height = gdk_window_get_height(window);</span><br><span class="line">  <span class="keyword">if</span>(width != <span class="number">0</span> &amp;&amp; height !=<span class="number">0</span>) &#123;</span><br><span class="line">    gtk_im_context_focus_in(context);</span><br><span class="line">    local_context = context;</span><br><span class="line">  &#125;</span><br><span class="line">  gdk_window_add_filter (window, event_filter, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译"><a class="header-anchor" href="#编译">¶ </a>编译</h3><p><code>gcc -shared -o libsublime-imfix.so sublime_imfix.c</code>pkg-config --libs --cflags gtk±2.0<code>-fPIC</code></p><h3 id="启动sublime"><a class="header-anchor" href="#启动sublime">¶ </a>启动sublime</h3><p><code>LD_PRELOAD=./libsublime-imfix.so subl</code></p><h3 id="添加到默认启动"><a class="header-anchor" href="#添加到默认启动">¶ </a>添加到默认启动</h3><p>查看sublime-text所在文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">which subl</span><br><span class="line">vi /usr/bin/subl</span><br></pre></td></tr></table></figure><p>复制libsublime-imfix.so到sublime所在文件夹：<br><code>sudo cp libsublime-imfix.so /opt/sublime_text</code></p><h4 id="方法一"><a class="header-anchor" href="#方法一">¶ </a>方法一</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/bin/</span><br><span class="line">sudo touch sublime_text3 </span><br><span class="line">sudo chmod a+x sublime_text3</span><br><span class="line">sudo vi sublime_text3</span><br></pre></td></tr></table></figure><p>添加内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">SUBLIME_HOME="/opt/sublime_text"</span><br><span class="line">LD_LIB=$SUBLIME_HOME/libsublime-imfix.so</span><br><span class="line">sh -c "LD_PRELOAD=$LD_LIB $SUBLIME_HOME/sublime_text $@"</span><br></pre></td></tr></table></figure><p>保存退出。</p><p>编辑<code>/usr/share/applications</code>将其中的三处<code>/opt/sublime_text/sublime_text</code>修改为<code>/usr/bin/sublime_text3</code>。</p><p>这样无论在终端中执行<code>sublime_text3</code>还是双击或者右键打开文本都可以输入中文了。</p><h4 id="方法二"><a class="header-anchor" href="#方法二">¶ </a>方法二</h4><p>编辑<code>/usr/bin/subl</code>，在最后一行上面添加：<br><code>export LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so</code></p><p>编辑<code>/usr/share/applications</code>将其中的三处<code>/opt/sublime_text/sublime_text</code>替换为<code>/usr/bin/subl</code></p><h3 id="参考"><a class="header-anchor" href="#参考">¶ </a>参考</h3><ul><li><a href="http://www.sublimetext.com/forum/viewtopic.php?f=3&amp;t=7006&amp;start=10#p41343" target="_blank" rel="noopener">Input method support</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sublime text </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建 Jenkins 编译 nightly version rom</title>
      <link href="2014/04/22/jekins_CI_build_rom/"/>
      <url>2014/04/22/jekins_CI_build_rom/</url>
      
        <content type="html"><![CDATA[<p>使用CI(持续集成)jekins编译nightly版的ROM</p><h3 id="安装apache"><a class="header-anchor" href="#安装apache">¶ </a>安装apache</h3><pre><code>sudo apt-get install apache2 </code></pre><h3 id="安装jenkins"><a class="header-anchor" href="#安装jenkins">¶ </a>安装jenkins</h3><p>切换到root用户下:</p><pre><code>echo deb http://pkg.jenkins-ci.org/debian binary/ &gt; /etc/apt/sources.list.d/jenkins.list </code></pre><p>切回用户:</p><pre><code>apt-get update &amp;&amp; apt-get install jenkins </code></pre><a id="more"></a><h3 id="其它"><a class="header-anchor" href="#其它">¶ </a>其它</h3><p>重启服务命令:</p><pre><code>/etc/init.d/jenkins restart </code></pre><p>安装完成后,系统中添加了一个用户jenkins,不要尝试修改该用户的密码.</p><p><code>/var/lib/jenkins</code>下面的文件都是jenkins用户的,对jenkins来说,这个目录就是它的home目录,所以修改这个下面的文件时注意文件的拥有者.</p><pre><code>sudo su - jenkins </code></pre><p>可以切换到该用户.</p><p>访问<code>localhost:8080</code>,首先要做的就是添加一个用户所用权限的用户，然后使用该用户sign up。</p><p>jenkins的配置文件在<code>/etc/default/jenkins</code>.</p><h3 id="setting-up-the-job"><a class="header-anchor" href="#setting-up-the-job">¶ </a>Setting up the job</h3><p>To use Jenkins to build regular nightlies for multiple devices, follow this quick steps:</p><ul><li>Prepare your Android source tree</li><li>Create a new job, as a multi-configuration project</li><li>In Advanced Project Options, check “Custom workspace”, and point both the Directory and Directory for sub-builds to the root of your Android tree</li><li>Add a new user-defined axis to the matrix, and call it ‘device’. In values, you must put each device you want to build, separated by spaces (e.g. ‘mako manta flo deb’).</li><li>Check ‘Run each configuration sequentially’</li><li>Add a new ‘Execute shell’ build step, in order to run a short build script. In Omni’s case we have a script at the root of our workspace, thus we put ‘./build_nightly.sh $device’, where $device will be replaced by each device for each build.</li><li>Save the job, you’re all set.</li></ul><p>Create then your build script. Here’s Omni build script:</p><pre><code>#!/bin/bashexport USE_CCACHE=1export CCACHE_DIR=/home/build/.ccacheexport BUILDTYPE_NIGHTLY=1DEVICE=$*cd /home/build/omni. build/envsetup.shrepo sync -j48rm -rf out/targetbrunch $DEVICE</code></pre><h3 id="adding-a-device-to-a-nightly-job"><a class="header-anchor" href="#adding-a-device-to-a-nightly-job">¶ </a>Adding a device to a nightly job</h3><p>Just add the device code into the ‘device’ axis in the job settings.</p><h3 id="遇到的问题"><a class="header-anchor" href="#遇到的问题">¶ </a>遇到的问题</h3><p>当脚本被触发运行时,使用的jenkins用户的环境变量,会出现找不到环境变量,和许多的权限问题.最后的解决方法是,新建一个节点,指向本机IP和workspace,以ssh登录即可.</p><h3 id="参考"><a class="header-anchor" href="#参考">¶ </a>参考</h3><ul><li><a href="http://docs.omnirom.org/Setting_up_Jenkins_for_building_nightlies" target="_blank" rel="noopener">Setting up Jenkins for building nightlies</a></li><li><a href="http://forum.xda-developers.com/showthread.php?t=2467004" target="_blank" rel="noopener">HOW TO AUTOMATE YOUR ROM BUILDING PROCESS</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将 Sublime Text 2 设置为默认编辑器</title>
      <link href="2013/11/22/set-sublimetext-to-default-editor/"/>
      <url>2013/11/22/set-sublimetext-to-default-editor/</url>
      
        <content type="html"><![CDATA[<p>虽然一直在用Sublime Text 2，但是一直比较懒，没有将其设置为默认编辑器。</p><h3 id="修改defaults-list"><a class="header-anchor" href="#修改defaults-list">¶ </a>修改defaults.list</h3><p>编辑<code>/etc/gnome/default.list</code>文件，将其中的所有<code>gedit.desktop</code>替换为<code>sublime-text-2.desktop</code>。</p><p>sublime-text-2.desktop在<code>/usr/share/applications/</code>目录下，使用<code>ls -al *sublime*</code>命令查看具体文件名。</p><a id="more"></a><h3 id="配置alternatives"><a class="header-anchor" href="#配置alternatives">¶ </a>配置alternatives</h3><p>执行：</p><pre><code>sudo update-alternatives --install /usr/bin/gnome-text-editor gnome-text-editor /usr/bin/sublime-text 300</code></pre><p>sublime-text在/usr/bin目录下，是一个可执行二进制文件。<br>然后：</p><pre><code>sudo update-alternatives --config gnome-text-editor</code></pre><p>输入sublime-text那一行的行数就行了。</p><p>OK!</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sublime text </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译极路由的 OpenWRT 固件</title>
      <link href="2013/11/12/openwrt-for-hiwifi/"/>
      <url>2013/11/12/openwrt-for-hiwifi/</url>
      
        <content type="html"><![CDATA[<p>虽然被坑了，看习惯了塑料外壳的个子老大的路由器，看一下小巧金属外壳的hiwifi还是很养眼的。从来没有接触过路由器固件的相关信息，现在有机会了，了解一下还是很好的，弄个下载机什么的。</p><h2 id="吐槽一下"><a class="header-anchor" href="#吐槽一下">¶ </a>吐槽一下</h2><p>极路由真是太坑爹了，照着小米学，学得不到家。最后真正成了欺骗用户了，虽然自己也是受害者。<br>知乎上有很好的回答，可惜近日已经删除了，不过还是能看出点什么的。</p><ul><li><a href="http://www.zhihu.com/question/21971379" target="_blank" rel="noopener">如何评价极路由公司 2013 年 11 月发布的「极贰」路由器？</a></li><li><a href="http://www.zhihu.com/question/21996327" target="_blank" rel="noopener">为什么网络上极路由的负面评价那么多？</a></li></ul><p>虽然被坑了，看习惯了塑料外壳的个子老大的路由器，看一下小巧金属外壳的hiwifi还是很养眼的。<br>从来没有接触过路由器固件的相关信息，现在有机会了，了解一下还是很好的，弄个下载机什么的。</p><a id="more"></a><h2 id="编译hiwifi的openwrt固件"><a class="header-anchor" href="#编译hiwifi的openwrt固件">¶ </a>编译hiwifi的openwrt固件</h2><h3 id="环境准备"><a class="header-anchor" href="#环境准备">¶ </a>环境准备</h3><p>至于环境就没啥好准备的了，自己的电脑编译环境还是很全的。<br>不过，hiwifi的代码是用svn管理的，从没有用过svn，还是先装一个。</p><pre><code>sudo apt-get install subversion git</code></pre><h3 id="获取源码"><a class="header-anchor" href="#获取源码">¶ </a>获取源码</h3><pre><code>svn co https://code.hiwifi.com/svn/hiwifi</code></pre><p>遇到提示输入密码时，直接打回车，然后出来输入用户名的提示，输入极客社区帐号email，再输入密码。</p><h3 id="编译"><a class="header-anchor" href="#编译">¶ </a>编译</h3><pre><code>cd hiwifi/trunk./scripts/feeds update -a./scripts/feeds install -amake package/symlinks </code></pre><h4 id="使用默认的编译选项"><a class="header-anchor" href="#使用默认的编译选项">¶ </a>使用默认的编译选项</h4><pre><code>make HC6361_defconfig </code></pre><h4 id="也可以自定义编译选项-这才是精华所在"><a class="header-anchor" href="#也可以自定义编译选项-这才是精华所在">¶ </a>也可以自定义编译选项（这才是精华所在）</h4><pre><code>make menuconfig</code></pre><p>可以把openssh、python、pythonopenssl、unbound等，都配置进去。</p><p>最后：</p><pre><code>make -j4</code></pre><p>如果出错，要查看详细的编译信息可以使用<code>V=s</code>参数:</p><pre><code>make -j4 V=s</code></pre><p>开始漫长的编译。</p><h3 id="制作成recovery-bin"><a class="header-anchor" href="#制作成recovery-bin">¶ </a>制作成recovery.bin</h3><pre><code>    wget -O rom.bin http://updaterom.ikcd.net/upgrade_file/HC6361-0.775.784s_130802-131633-96d56f0c    dd if=rom.bin of=uboot.bin bs=1k count=128    cat uboot.bin bin/ar71xx/openwrt-ar71xx-generic-tw150v1-squashfs-sysupgrade.bin &gt;recovery.bin</code></pre><p>上面的链接404，暂时的解决方法是跳过wget，手动下载官方的一个<a href="http://bbs.hiwifi.com/thread-7710-1-1.html" target="_blank" rel="noopener">recovery.bin</a>，重命名为rom.bin然后执行下面的命令提取uboot.bin。</p><h3 id="刷机"><a class="header-anchor" href="#刷机">¶ </a>刷机</h3><ul><li>去这里下载<a href="http://bbs.hiwifi.com/thread-7710-1-1.html" target="_blank" rel="noopener">官方开源版本固件</a>，解压</li><li>将上一步生成的recovery.bin替换目录中recovery.bin</li><li>用网线将极路由 LAN 口与电脑网口相连</li><li>将电脑网络接口 IP 设置为 192.168.1.88/255.255.255.0</li><li>用尖锐物按住极路由 RESET 不放，给极路由加电</li><li>等待电脑上 tftpd 出现传输 recovery.bin 进度条完成后，松开 RESET</li><li>极路由面板灯进入跑马灯状态，跑完后，系统自动重启，刷机完成</li></ul><h2 id="参考-扩展阅读"><a class="header-anchor" href="#参考-扩展阅读">¶ </a>参考，扩展阅读</h2><ul><li><a href="http://chaopeng.me/blog/2013/10/28/hiwifi.html" target="_blank" rel="noopener">极路由的正确玩法</a></li><li><a href="http://www.openwrt.org.cn/bbs/forum.php?mod=viewthread&amp;tid=14193" target="_blank" rel="noopener">OpenWrt安装goagent实例教程</a></li><li><a href="http://blog.csdn.net/conupefox/article/details/8557253" target="_blank" rel="noopener">Openwrt架设DNS转发器，解决污染问题 </a></li><li><a href="https://code.google.com/p/openwrt-hiwifi/" target="_blank" rel="noopener">openwrt-hiwifi</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Openwrt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hiwifi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 下 mail 命令的使用</title>
      <link href="2013/10/31/linux-send-mail/"/>
      <url>2013/10/31/linux-send-mail/</url>
      
        <content type="html"><![CDATA[<p>因为服务器上 android 项目的一个编译脚本，要检测编译的状况。要增加一个发送 email 的功能，可以以前没有用过，就研究一下。</p><h2 id="安装"><a class="header-anchor" href="#安装">¶ </a>安装</h2><p>安装 mailutils</p><pre><code>sudo apt-get install mailutils</code></pre><p>因为还要发送附件，需安装</p><pre><code>sudo apt-get install sharutils</code></pre><a id="more"></a><h2 id="发送方式"><a class="header-anchor" href="#发送方式">¶ </a>发送方式</h2><h3 id="一般的发送方式"><a class="header-anchor" href="#一般的发送方式">¶ </a>一般的发送方式</h3><pre><code>mail address@address.com</code></pre><p>编辑抄送对象，邮件主题，邮件正文后，按 Ctrl-D 结束。</p><h3 id="快速发送方式"><a class="header-anchor" href="#快速发送方式">¶ </a>快速发送方式</h3><pre><code>echo “邮件正文” | mail -s &quot;邮件主题&quot; address@address.com</code></pre><h3 id="以文件内容作为邮件正文来发送"><a class="header-anchor" href="#以文件内容作为邮件正文来发送">¶ </a>以文件内容作为邮件正文来发送</h3><pre><code>mail -s &quot;邮件主题&quot; address@address.com &lt; 邮件正文.txt</code></pre><h3 id="发送带附件的邮件"><a class="header-anchor" href="#发送带附件的邮件">¶ </a>发送带附件的邮件</h3><pre><code>uuencode 附件名称 附件显示名称 | mail -s &quot;邮件主题&quot; address@address.com </code></pre><p>例如：</p><pre><code> uuencode test.txt test.txt | mail -s Test address@gmail.com</code></pre><h3 id="以文件内容作为邮件正文和同时发送附件"><a class="header-anchor" href="#以文件内容作为邮件正文和同时发送附件">¶ </a>以文件内容作为邮件正文和同时发送附件</h3><p>没有找到什么便利的方法<br>例：</p><pre><code>uuencode log.tar.gz log.tar.gz &gt; attachment.txtcat info.txt attachment.txt &gt; combined.txtmail -s &quot;服务器编译错误，请查看日志文件&quot; x2280854@gmail.com &lt; combined.txt</code></pre><p>经测试，发送到 gmail 邮箱，邮件正文和附件是可以正确识别的。而发送到 163 的公司邮箱，无法正确识别，而是把整个 combined.txt 当作了正文。</p><h2 id="11-26-更新"><a class="header-anchor" href="#11-26-更新">¶ </a>11.26 更新</h2><h3 id="遇到的一个错误"><a class="header-anchor" href="#遇到的一个错误">¶ </a>遇到的一个错误</h3><p>最近一段时间服务器上的邮件，一直无法成功发送到我的邮箱，今天抽空看了一下。</p><pre><code>/usr/lib/sendmail -bp</code></pre><p>错误日志：</p><blockquote><p>47DA518ADCE6      397 Tue Nov 26 14:40:39  shenduos@Raphael-DeepinLinux<br>(Host or domain name not found. Name service error for <a href="http://name=gmail.com" target="_blank" rel="noopener">name=gmail.com</a> type=MX: Host not found, try again)<br><a href="mailto:x2280854@gmail.com" target="_blank" rel="noopener">x2280854@gmail.com</a></p></blockquote><p>最后的问题在：</p><pre><code>/var/spool/postfix/etc/resolv.conf</code></pre><p>编辑 <code>/var/spool/postfix/etc/resolv.conf</code>，文件内容应该和 <code>/etc/resolv.conf</code> 中一样。</p><h2 id="参考"><a class="header-anchor" href="#参考">¶ </a>参考</h2><ul><li><a href="http://blog.csdn.net/c395565746c/article/details/6011731" target="_blank" rel="noopener">Linux mail命令使用 </a></li><li><a href="http://sunxiaqw.blog.163.com/blog/static/99065438201010182277261/" target="_blank" rel="noopener">linux下mail命令使用(转)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git stash 的使用</title>
      <link href="2013/10/22/git-stash/"/>
      <url>2013/10/22/git-stash/</url>
      
        <content type="html"><![CDATA[<p>对于有时某些未完善的修改，并不想commit时，而又有需求切换分支工作时，这时git stash命令就派上用场了</p><h2 id="搁置修改"><a class="header-anchor" href="#搁置修改">¶ </a>搁置修改</h2><p>有时在分支上有未提交的修改，因为要切到其它分支或要做其它修改测试，因修改未整理，不想提交。这时就可以使用stash命令，例：</p><pre><code>git add .git stash</code></pre><p>这样把未提交的修改暂时搁置，所有文件恢复到未修改之前的，然后就可以进行其它的工作了</p><a id="more"></a><h2 id="恢复搁置的修改"><a class="header-anchor" href="#恢复搁置的修改">¶ </a>恢复搁置的修改</h2><p>恢复之前搁置的修改：</p><pre><code>git stash apply</code></pre><h2 id="git-stash-的其它命令"><a class="header-anchor" href="#git-stash-的其它命令">¶ </a>git stash 的其它命令</h2><h3 id="查看所有之前搁置的修改"><a class="header-anchor" href="#查看所有之前搁置的修改">¶ </a>查看所有之前搁置的修改</h3><pre><code>git stash list</code></pre><h3 id="恢复其中的某个修改"><a class="header-anchor" href="#恢复其中的某个修改">¶ </a>恢复其中的某个修改</h3><pre><code>git stash apply stash@{1} #注意这是找回第二个git stash pop #找回第一个</code></pre><h3 id="删除某个stash"><a class="header-anchor" href="#删除某个stash">¶ </a>删除某个stash</h3><pre><code>git stash drop &lt;id&gt;</code></pre><h3 id="删除所有stash"><a class="header-anchor" href="#删除所有stash">¶ </a>删除所有stash</h3><pre><code>git stash clear</code></pre>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Sublime Text 2 编辑 Markdown</title>
      <link href="2013/10/17/sublime-text2-edit-markdown/"/>
      <url>2013/10/17/sublime-text2-edit-markdown/</url>
      
        <content type="html"><![CDATA[<p>Sublime Text 2 现在做为我的第一编辑器，用好它还需要一个漫长的过程。学习Markdown必须找一个合手的编辑器</p><h2 id="sublime-text-2的配置"><a class="header-anchor" href="#sublime-text-2的配置">¶ </a>Sublime Text 2的配置</h2><p>这里使用了两个插件：</p><ul><li>MarkdownEditing</li><li>Markdown Preview</li></ul><p>Markdown Preview是预览插件。安装过程，待以后补全。</p><a id="more"></a><h2 id="sublime-text-2的快捷键"><a class="header-anchor" href="#sublime-text-2的快捷键">¶ </a>Sublime Text 2的快捷键</h2><ul><li>Ctrl+Win+V 选中的内容将自动转换为行内式超链接，链接到剪贴板中的内容</li><li>Ctrl+Win+R 选中的内容将自动转换为参考式超链接，链接到剪贴板中的内容</li><li>Ctrl+Alt+R 弹出提示框插入一个参考式超链接，在提示框中输入链接内容和定义参考ID[^3]</li><li>Ctrl+Win+K 插入一个标准的行内式超链接</li><li>Win+Shift+K 插入一个标准的行内式图片（此快捷键可能与输入法有冲突）</li><li>Ctrl+1 至 Ctrl+6 插入一级至六级标题</li><li>Win+Alt+i 选中的内容转换为斜体</li><li>Win+Alt+b 选中的内容转换为粗体[^1]</li><li>Ctrl+Shift+6 自动插入一个脚注，并跳转到该脚注的定义中。</li><li>Alt+Shift+F 查找没有定义的脚注并自动添加其定义链接</li><li>Alt+Shift+G 查找没有定义的参考式超链接并自动添加其定义链接</li><li>Ctrl+Alt+S 脚注排序</li><li>Ctrl+Shift+. 缩进当前内容</li><li>Ctrl+Shift+, 提前当前内容</li></ul><h2 id="其它ubuntu-下的markdown-工具"><a class="header-anchor" href="#其它ubuntu-下的markdown-工具">¶ </a>其它Ubuntu 下的Markdown 工具</h2><ul><li><a href="http://sourceforge.net/p/retext/home/ReText/" target="_blank" rel="noopener">ReTex</a></li><li><a href="http://mahua.jser.me/" target="_blank" rel="noopener">mahua</a></li></ul><p>其中第二个mahua是在线编辑器，都可以实现实时预览。</p><h3 id="retex-ubuntu-13-04下安装过程"><a class="header-anchor" href="#retex-ubuntu-13-04下安装过程">¶ </a>ReTex Ubuntu 13.04下安装过程</h3><pre><code>sudo add-apt-repository ppa:mitya57sudo apt-get updatesudo apt-get install retext</code></pre><h2 id="一个markdown语法高亮主题"><a class="header-anchor" href="#一个markdown语法高亮主题">¶ </a>一个Markdown语法高亮主题</h2><ul><li><a href="https://dl.dropbox.com/u/837457/sublime%20text%202/Monokai-custom.tmTheme" target="_blank" rel="noopener">Monokai-custom.tmTheme</a></li></ul><p>放到~/.config/sublime-text-2/Packages/User/ 文件夹下，在Preferences -&gt; Color Scheme -&gt; User选择Monokai-custom。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sublime text </tag>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将 WordPress 的数据迁移到 Jekyll</title>
      <link href="2013/10/16/migrate-wp-jekyll/"/>
      <url>2013/10/16/migrate-wp-jekyll/</url>
      
        <content type="html"><![CDATA[<p>遇到了太多的麻烦，整个重来了好几遍</p><p>官方文档:</p><p><a href="http://jekyllrb.com/docs/migrations/" target="_blank" rel="noopener">http://jekyllrb.com/docs/migrations/</a></p><p>安装过程中出错，因为 ruby 版本太低，要更新版本到 1.9.2，因为先前的工作并没有更新 ruby 的版本，导致遇到了很多麻烦，所以重新来了一遍。更新 ruby 的方法，已经放到了第一篇文章中去了。</p><p>备份 wordpress 的文章:</p><p>进入 wordpress 的后台，工具-导出，导出文章即可，是一个 xml 文件</p><p>前期准备，这里使用从 xml 导出的方式，从数据库导出一直没有搞定</p><a id="more"></a><pre><code>sudo gem install hpricot </code></pre><p>这里使用别人修改好了的脚本，官方脚本对中文支持不友好：</p><p><a href="https://gist.github.com/chitsaou/1394128" target="_blank" rel="noopener">https://gist.github.com/chitsaou/1394128</a></p><p>将备份的 wordpress.xml 放到项目的根目录，把脚本放到新建的 <code>utils</code> 目录中，然后运行：</p><pre><code>sudo ruby -r &quot;./utils/wordpressdotcom.rb&quot; -e &quot;Jekyll::WordpressDotCom.process&quot;</code></pre><p>因为边一直使用了 sudo，导致后来出了很多问题，不得不使用 sudo 才行。</p><p>转换好的文章在 <code>source</code> 目录中。</p><p>把 html 转换成 markdown 真是个力气活，最后还有手动纠正很多错误才行。</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jekyll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 github 搭建静态博客</title>
      <link href="2013/10/14/my-first-post/"/>
      <url>2013/10/14/my-first-post/</url>
      
        <content type="html"><![CDATA[<p>这是首次使用 githubpages 的第一篇博文，也是一篇教程</p><h2 id="安装-jekyll"><a class="header-anchor" href="#安装-jekyll">¶ </a>安装 Jekyll</h2><h3 id="更新-ruby-版本"><a class="header-anchor" href="#更新-ruby-版本">¶ </a>更新 Ruby 版本</h3><p>已弃用，请查看新方法</p><a id="more"></a><p>此环境需要 ruby 的版本 &gt;=1.9.2，<code>ruby -v</code>查看 ruby 的版本，如果版本低于 1.9.2，得更新 ruby</p><pre><code>curl -L https://get.rvm.io | bash -s stable --ruby</code></pre><p>编辑 <code>~/.bashrc</code>，将 <code>~/.bash_profile</code> 中的文本复制到 <code>.bashrc</code> 末尾，然后更新环境变量：</p><pre><code>source ~/.bashrc</code></pre><p>然后安装 1.9.2：</p><pre><code>rvm install 1.9.2</code></pre><p>此时 <code>ruby -v</code> 查看版本 ruby 的版本默认为最新的，设置为默认的 1.9.2：</p><pre><code>rvm --default 1.9.2</code></pre><p>也可以暂时调整使用其它版本如：</p><pre><code>rvm use 1.9.3</code></pre><p>如果版本不对，请按照上诉步骤更新环境变量。</p><h4 id="新方法"><a class="header-anchor" href="#新方法">¶ </a>新方法</h4><p>以上方法虽然可以允许自定义但是很麻烦，使用的是 ubuntu13.04，源中有 ruby1.9.3 版本，直接安装，弃用以上方法。</p><pre><code>sudo apt-get install ruby1.9.3</code></pre><h3 id="安装-jekyll-v2"><a class="header-anchor" href="#安装-jekyll-v2">¶ </a>安装 jekyll</h3><p>为了在本地可以测试，直观的看到修改后的展示效果，需要安装 jekyll</p><pre><code>sudo apt-get install rubygems</code></pre><p>然后使用 gem 命令安装以下包：</p><pre><code>sudo gem install jekyllsudo gem install rdiscount</code></pre><p>国外的 gem 源，也许比较慢，可以更改 gem 的源（未测试）</p><pre><code>sudo gem sources --remove http://rubygems.org/sudo gem sources -a http://ruby.taobao.org/ </code></pre><h2 id="创建项目"><a class="header-anchor" href="#创建项目">¶ </a>创建项目</h2><p>在你的 github 上创建一个项目 <a href="http://username.github.com" target="_blank" rel="noopener">username.github.com</a>， username 为你在 github 上的用户名，创建时可以初始化一个 readme.m d和 jekyll 的<br>.gitignore 文件</p><p>将你的项目 git clone 到本地</p><h2 id="clone-一个模板"><a class="header-anchor" href="#clone-一个模板">¶ </a>clone 一个模板</h2><p>这里有很多 jekyll 的模板:</p><pre><code>https://github.com/mojombo/jekyll/wiki/sites</code></pre><p>clone 一个 Octopress 的模板:(有问题，木有搞定，换一个模板）</p><pre><code>git clone https://github.com/xuhdev/homepage.git</code></pre><p>使用</p><pre><code>https://github.com/beiyuu/beiyuu.github.com.git</code></pre><p>这个模板</p><p>然后删除其中的 .git 文件，copy 到你的项目目录</p><h2 id="本地查看效果"><a class="header-anchor" href="#本地查看效果">¶ </a>本地查看效果</h2><p>在你的项目目录下执行:</p><pre><code>jekyll serve</code></pre><p>如果没有什么错误发生的话，就可以在浏览器中浏览</p><pre><code>localhost:4000</code></pre><h2 id="开始自己的修改吧"><a class="header-anchor" href="#开始自己的修改吧">¶ </a>开始自己的修改吧</h2><p>测试没有问题的话，就可以开始自己的修改了。删除原来的文章，增加自己的文章，修改域名，博客标题， icon 等。本地测试一下没有问题的话，就可以 push 了。</p><p>下面就是开始努力的学习 markdown 语法了，这个东西对我最头痛排版的问题，简直是太爽 了，有种相见恨晚的赶脚。</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jekyll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mt6589 增加新的项目</title>
      <link href="2013/09/30/mt6589-add-new-project/"/>
      <url>2013/09/30/mt6589-add-new-project/</url>
      
        <content type="html"><![CDATA[<p>从自己的笔记中，摘抄出来的，一直没有整理</p><a id="more"></a><p>只有使用自定义签名时才使用项目签名:</p><p>配置选项为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MTK_SIGNATURE_CUSTOMIZATION = yes</span><br><span class="line">MTK_INTERNAL = no</span><br><span class="line">cp -fr build/target/product/security/$old_p/ build/target/product/security/$new_p/</span><br></pre></td></tr></table></figure><p>其它:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp -fr build/target/product/$old_p.mk build/target/product/$new_p.mk</span><br><span class="line">cp -fr mediatek/config/$old_p/ mediatek/config/$new_p/</span><br><span class="line">cp -fr mediatek/custom/$old_p/ mediatek/custom/$new_p/</span><br><span class="line">cp -fr vendor/mediatek/$old_p/ vendor/mediatek/$new_p/</span><br><span class="line">mv vendor/mediatek/$new_p/artifacts/out/target/product/$old_p vendor/mediatek/$new_p/artifacts/out/target/product/$new_p</span><br></pre></td></tr></table></figure><p>还有<br><code>/vendor/mediatek/$project/artifacts/target.txt</code><br>修改里面的 $project 为 $new_p</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MTK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mt6589 禁用 Navigation Bar</title>
      <link href="2013/08/29/mt6589-disable-navigation-bar/"/>
      <url>2013/08/29/mt6589-disable-navigation-bar/</url>
      
        <content type="html"><![CDATA[<p>默认 Navigation Bar 的控制在</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bool</span> <span class="attr">name</span>=<span class="string">"config_showNavigationBar"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">bool</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>alps/frameworks/base/core/res/res/values/config.xml</code> 文件中</p></blockquote><a id="more"></a><p>6589 navigation Bar 最终控制在，会覆盖掉上述设置：<br><code>alps/mediatek/custom/project_name/resource_overlay/generic/frameworks/base/core/res/res/values/config.xml</code></p><p>所以主要修改 config 中的 overlay 为 false。</p><p>但是有的在 build.prop 中又定义了 qemu.hw.mainkeys，可以在 config 中的 system.prop 中去掉，或者改为 qemu.hw.mainkeys=1。如果 <a href="http://buildinfo.sh" target="_blank" rel="noopener">buildinfo.sh</a> 中有此定义，也可以修改掉</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MTK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恢复删除的分支、或者丢失的 commit</title>
      <link href="2013/08/12/recover-deleted-branches-lost-commit/"/>
      <url>2013/08/12/recover-deleted-branches-lost-commit/</url>
      
        <content type="html"><![CDATA[<p>手一哆嗦把分支删掉了，干掉了好几天的工作成果，不甘心。谁让咱git使用没那么牛呢，遂找办法。还是把《git权威指南》细细看完吧。</p><p>转自：<a href="http://sumsung753.blog.163.com/blog/static/146364501201301711943864/" target="_blank" rel="noopener">http://sumsung753.blog.163.com/blog/static/146364501201301711943864/</a></p><p>在使用Git的过程中，有时可能会有一些误操作</p><p>比如：执行<code>checkout -f</code> 或  <code>reset -hard</code> 或  <code>branch -d</code>删除一个分支</p><p>结果造成本地（远程）的分支或某些commit丢失</p><a id="more"></a><p>可以通过reflog来进行恢复，前提是丢失的分支或commit信息没有被git gc清除</p><p>一般情况下，gc对那些无用的object会保留很长时间后才清除的</p><p>reflog是git提供的一个内部工具，用于记录对git仓库进行的各种操作</p><p>可以使用<code>git reflog show</code>或<code>git log -g</code>命令来看到所有的操作日志</p><p>恢复的过程很简单：</p><ol><li><p>通过<code>git log -g</code> 命令来找到我们需要恢复的信息对应的commit_id，可以通过提交的时间和日期来辨别。一个好的办法是运行：</p><ul><li>git log --since=“2 weeks ago” – myfile #可以查看2个星期期间的myfile历史</li><li>git log --branches=“developer” #可以查看某个developer的commit</li></ul></li><li><p>通过git branch recover_branch[新分支] commit_id 来建立一个新的分支</p></li></ol><p>这样，我们就把丢失的东西给恢复到了recover_branch分支上了。</p><p>Q:如果是不小心执行了git reset，还有办法取消吗？</p><p>A:git reflog 查看操作历史，找到之前 HEAD 的 hash 值，然后 git reset --hard 到那个 hash 即可。</p><p>Q:怎样找回历史版本中删除的文件？</p><p>A:先确定需要恢复的文件要恢复成哪一个历史版本(commit)，假设那个版本号是： commit_id，那么</p><pre><code>git checkout [commit_id] — &lt;path_to_file&gt;</code></pre><p>就可以恢复。</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 13.04 上搭建LAMP本地服务器</title>
      <link href="2013/06/24/ubuntu13-04-build-local-server-lamp/"/>
      <url>2013/06/24/ubuntu13-04-build-local-server-lamp/</url>
      
        <content type="html"><![CDATA[<p>这是以前的一篇在本地测试用的</p><h2 id="安装"><a class="header-anchor" href="#安装">¶ </a>安装</h2><h3 id="安装mysql"><a class="header-anchor" href="#安装mysql">¶ </a>安装MYSQL</h3><pre><code>sudo apt-get install mysql-serversudo apt-get install mysql-client</code></pre><a id="more"></a><p>安装mysql-server的过程中需要设置root用户的密码</p><h3 id="安装apache"><a class="header-anchor" href="#安装apache">¶ </a>安装Apache</h3><pre><code>sudo apt-get install apache2</code></pre><h3 id="安装php"><a class="header-anchor" href="#安装php">¶ </a>安装PHP</h3><pre><code>sudo apt-get install php5sudo apt-get install libapache2-mod-auth-mysqlsudo apt-get install php5-mysql</code></pre><!--more--><h3 id="安装phpmyadmin"><a class="header-anchor" href="#安装phpmyadmin">¶ </a>安装phpMyadmin</h3><pre><code>sudo apt-get install phpmyadminsudo ln -s /usr/share/phpmyadmin</code></pre><p>安装过程中配置phpMyadmin，服务器要选择apache。需要输入数据库的登陆密码，并设置phpMyadmin的登陆密码</p><h2 id="测试"><a class="header-anchor" href="#测试">¶ </a>测试</h2><h3 id="修改权限"><a class="header-anchor" href="#修改权限">¶ </a>修改权限</h3><pre><code>chown username /var/www（将username替换为您当前用户的用户名）chmod 777 /var/www/</code></pre><h3 id="检测mysql是否正常"><a class="header-anchor" href="#检测mysql是否正常">¶ </a>检测Mysql是否正常</h3><p>在终端中输入：</p><pre><code>mysql -uroot -p</code></pre><p>输入密码，看是否可正常登陆</p><h3 id="检测apache是否正常"><a class="header-anchor" href="#检测apache是否正常">¶ </a>检测Apache是否正常</h3><p>在浏览器中打开：<a href="http://localhost" target="_blank" rel="noopener">http://localhost/</a></p><p>如果出现如下信息，则表明正常。</p><blockquote><p>It works!</p></blockquote><p>This is the default web page for this server.</p><blockquote><p>The web server software is running but no content has been added, yet.</p></blockquote><h3 id="检测php是否正常"><a class="header-anchor" href="#检测php是否正常">¶ </a>检测PHP是否正常</h3><p>Ubuntu下Apache的默认安装路径为/var/www/，到其目录下新建info.php文件，文件内容为：</p><p>然后在浏览器中打开：<a href="http://localhost/info.php" target="_blank" rel="noopener">http://localhost/info.php</a> 看是否正常。</p><h3 id="检查phpmyadmin是否正常"><a class="header-anchor" href="#检查phpmyadmin是否正常">¶ </a>检查phpMyadmin是否正常</h3><p>在浏览器中访问<a href="http://localhost/phpmyadmin" target="_blank" rel="noopener">http://localhost/phpmyadmin</a>，到phpMyAdmin的登陆界面</p><p>重启apache服务器：</p><p>做完一些修改后有时要重启一下：</p><pre><code>sudo /etc/init.d/apache2 restart</code></pre>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LAMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 13.04 gcc 版本降级</title>
      <link href="2013/05/30/ubunt13-04-gcc-downgrade/"/>
      <url>2013/05/30/ubunt13-04-gcc-downgrade/</url>
      
        <content type="html"><![CDATA[<p>遇到的一个问题：</p><p>在ubuntu中安装完virtualbox，启动时出错，按照提示执行：<br><code>sudo /etc/init.d/vboxdrv setup</code></p><p>再模块加载时出了一个错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* Modprobe vboxdrv failed. Please use &apos;dmesg&apos; to find out why.</span><br></pre></td></tr></table></figure><p>查看log，<code>/var/log/vbox-install.log</code>，怀疑是gcc的问题</p><p>遂将gcc版本升级为4.7，再次执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/vboxdrv setup</span><br></pre></td></tr></table></figure><p>时成功通过，并启动。然后又将gcc版本降为4.4。</p><a id="more"></a><p>ubuntu13.04 的 gcc 版本是 4.7.3 的，防止以后编译时因版本太高而出现的编译错误，将版本降为 4.4.</p><p>查看版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -v</span><br></pre></td></tr></table></figure><p>安装gcc4.4：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install g++-4.4-multilib gcc-4.4-multilib</span><br></pre></td></tr></table></figure><p>注意软链：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/bin/gcc* -l</span><br><span class="line">ls /usr/bin/g++* -l</span><br></pre></td></tr></table></figure><p>修改软链:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/bin/</span><br><span class="line">sudo mv gcc gcc.bak</span><br><span class="line">sudo ln -s gcc-4.4 gcc</span><br></pre></td></tr></table></figure><p>同样的修改g++：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mv g++ g++.bak</span><br><span class="line">sudo ln -s g++-4.4 g++</span><br></pre></td></tr></table></figure><p>再次查看版本号，OK</p>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GCC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
